<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Louis睡醒了</title>
  <icon>https://www.gravatar.com/avatar/e3357417f3bf92b841d72b4abf701b40</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.jiangluyu.xyz/"/>
  <updated>2022-02-22T15:20:12.668Z</updated>
  <id>https://www.jiangluyu.xyz/</id>
  
  <author>
    <name>Louis</name>
    <email>945803847@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常用排序算法详解</title>
    <link href="https://www.jiangluyu.xyz/2022/02/22/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>https://www.jiangluyu.xyz/2022/02/22/常用排序算法详解/</id>
    <published>2022-02-22T15:12:00.000Z</published>
    <updated>2022-02-22T15:20:12.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>Playground在线运行地址：<a href="https://leetcode-cn.com/playground/rKzLfEEY/">https://leetcode-cn.com/playground/rKzLfEEY/</a></p><div class="table-container"><table><thead><tr><th style="text-align:center">排序算法</th><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最坏情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">排序方式</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">In-place</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">选择排序</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">In-place</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">插入排序</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">In-place</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">希尔排序</td><td style="text-align:center">$O(nlogn)$</td><td style="text-align:center">$O(nlogn)$</td><td style="text-align:center">$O(nlogn)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">In-place</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center">$O(nlogn)$</td><td style="text-align:center">$O(nlogn)$</td><td style="text-align:center">$O(nlogn)$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">Out-place</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">快速排序</td><td style="text-align:center">$O(nlogn)$</td><td style="text-align:center">$O(nlogn)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(logn)$</td><td style="text-align:center">In-place</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center">$O(nlogn)$</td><td style="text-align:center">$O(nlogn)$</td><td style="text-align:center">$O(nlogn)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">In-place</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">计数排序</td><td style="text-align:center">$O(n+k)$</td><td style="text-align:center">$O(n+k)$</td><td style="text-align:center">$O(n+k)$</td><td style="text-align:center">$O(k)$</td><td style="text-align:center">Out-place</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">桶排序</td><td style="text-align:center">$O(n+k)$</td><td style="text-align:center">$O(n+k)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n+k)$</td><td style="text-align:center">Out-place</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">基数排序</td><td style="text-align:center">$O(n×k)$</td><td style="text-align:center">$O(n×k)$</td><td style="text-align:center">$O(n×k)$</td><td style="text-align:center">$O(n+k)$</td><td style="text-align:center">Out-place</td><td style="text-align:center">稳定</td></tr></tbody></table></div><a id="more"></a><p>注：</p><blockquote><p>稳定性：相同数字是否保持原顺序</p><p>排序方式：是否需要占据额外空间，需要为<code>Out-place</code>，不需要为<code>In-place</code></p><p>以下代码实现均为升序（小→大）（除堆外）</p></blockquote><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>思想：遍历数组n次（n为数的个数），比较两个数的大小，较大的数下沉，较小的数上浮。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = arr.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123; <span class="comment">// 表示第i轮</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = size - <span class="number">1</span>; j &gt; i; j--) &#123; <span class="comment">// 从最后一个数开始依次向前比较，由于每次将最小的数浮到水面（即i）以上，因此每过一轮，需要比较的次数就变少一次</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                swap(arr[j], arr[j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化：由于数据顺序排好以后，冒泡算法仍然会进行下一轮的比较，尽管后面的遍历都是多余的。因此，设置标志位，若某一轮没有发生交换，则结束排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort_op</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = arr.size();</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = size - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                swap(arr[j], arr[j<span class="number">-1</span>]);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>思想：每次选择数组中剩余数中最小的，将其放到前面（与对应位置的数交换）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = arr.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIdx = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = size - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIdx]) &#123;</span><br><span class="line">                minIdx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr[i], arr[minIdx]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>思想：遍历数组，第k个数分别与前k-1个数比较，找到自己的位置并插入（实现上还是用的交换）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = arr.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123; <span class="comment">// 表示第i轮</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123; <span class="comment">// 从第二个数开始，与前面的数依次比较，直到找到位置</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                swap(arr[j], arr[j<span class="number">-1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>思想：又叫最小增量排序，将要排序的数组根据某个增量分为若干子序列，并对子序列进行插入排序，然后将增量逐渐缩小，重复上述过程，直至增量为1，此时数组基本有序，最后再进行插入排序。</p><p>帮助理解：</p><p>假设有一组数据：</p><p>59 20 17 13 28 14 23 83</p><hr><p><strong>第一轮：</strong>增量为4（子序列为[0, 4], [1, 5], [2, 6], [3, 7])</p><p>首先i=4，即选中arr[4]即28，将其与arr[4-4]即59作为一个子序列进行插入排序，结果为：</p><p><strong>28</strong> 20 17 13 <strong>59</strong> 14 23 83</p><p>接着i=5，即选中arr[5]即14，将其与arr[5-4]即20作为一个子序列进行插入排序，结果为：</p><p>28 <strong>14</strong> 17 13 59 <strong>20</strong> 23 83</p><p>接着i=6，即选中arr[6]即23，将其与arr[6-4]即17作为一个子序列进行插入排序，由于17&lt;23，序列不变；</p><p>接着i=7，即选中arr[7]即83，将其与arr[5-4]即13作为一个子序列进行插入排序，由于13&lt;83，序列不变；</p><p>最终结果为：</p><p><strong>28 14</strong> 17 13 <strong>59 20</strong> 23 83</p><hr><p><strong>第二轮：</strong>增量为2（子序列为[0, 2, 4, 6], [1, 3, 5, 7])</p><p>结果为：</p><p><strong>17 13 23 14 28 20 59</strong> 83</p><hr><p><strong>第三轮：</strong>增量为1</p><p>即将整个数组作为序列进行插入排序，结果为：</p><p><strong>13 14 17 20 23 28</strong> 59 83</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = arr.size();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> incr = size / <span class="number">2</span>; incr &gt; <span class="number">0</span>; incr /= <span class="number">2</span>) &#123; <span class="comment">// 表示增量increment</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = incr; i &lt; size; i++) &#123; <span class="comment">// 根据增量划分子序列并进行插入排序</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= incr; j -= incr) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j-incr] &gt; arr[j]) &#123;</span><br><span class="line">                    swap(arr[j], arr[j-incr]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>思想：分治法，将数组分成两组A，B，如果A，B组内有序，那么归并这两个子序列就得到了有序序列，为了使A，B有序，以此类推，将A，B分别再分成两组，如此分下去，直到每个组内只有一个数字时，该子序列就达到了有序，最后我们将相邻子序列两两归并即可。</p><p>动态版：</p><div align=center><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200303015136.gif"></div><p>静态版：</p><div align=center><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200303015137.jpg"></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (begin + end) / <span class="number">2</span>;</span><br><span class="line">        merge_sort(arr, begin, mid); <span class="comment">// 将左半部分排好序</span></span><br><span class="line">        merge_sort(arr, mid + <span class="number">1</span>, end); <span class="comment">// 将右半部分排好序</span></span><br><span class="line">        merge(arr, begin, mid, end); <span class="comment">// 归并左右部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> begin, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> size = end - begin + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp(size, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> pLeft = begin;</span><br><span class="line">    <span class="keyword">int</span> pRight = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">bool</span> endLeft = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> endRight = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!endLeft &amp;&amp; !endRight) &#123; <span class="comment">// 若左右序列均未到达终点</span></span><br><span class="line">            <span class="keyword">if</span> (arr[pLeft] &lt; arr[pRight]) &#123; <span class="comment">// 取左右指针所指向元素中较小的那一个</span></span><br><span class="line">                temp[i] = arr[pLeft++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[i] = arr[pRight++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pLeft &gt; mid) &#123; <span class="comment">// 判定左右序列是否已到达终点，若是则标记</span></span><br><span class="line">                endLeft = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pRight &gt; end) &#123;</span><br><span class="line">                endRight = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 若左右至少有一个已经到达终点，则将未到达终点的序列剩余部分加在temp后面</span></span><br><span class="line">        <span class="keyword">if</span> (!endLeft) &#123;</span><br><span class="line">                temp[i] = arr[pLeft++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[i] = arr[pRight++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>, k = begin; j &lt; size; j++, k++) &#123; <span class="comment">// 将temp中的数按序存回arr</span></span><br><span class="line">        arr[k] = temp[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>思想：分治法，先从序列中选出一个数作为pivot，将比这个数小的数放在其左边，大的数放在其右边。然后，对左右两个子序列重复上一步，直至各子区间内只有一个数。</p><p>动态版：</p><div align=center><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200303190241.gif"></div><p>帮助理解：</p><p>例如，我们有这样一组序列：<strong>72</strong> 6 57 88 <strong>60</strong> 85 42 83 73 <strong>48</strong>，初始化pivot=60（这里的pivot为arr[begin], arr[mid], arr[end]的中间值），将其交换至首端。</p><p>对该序列进行划分：</p><div class="table-container"><table><thead><tr><th style="text-align:center">60</th><th style="text-align:center">6</th><th style="text-align:center">57</th><th style="text-align:center">88</th><th style="text-align:center">72</th><th style="text-align:center">85</th><th style="text-align:center">42</th><th style="text-align:center">83</th><th style="text-align:center">73</th><th style="text-align:center">48</th><th style="text-align:center">初始化</th></tr></thead><tbody><tr><td style="text-align:center">pivot, left</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">right</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>60</strong></td><td style="text-align:center">6</td><td style="text-align:center">57</td><td style="text-align:center"><strong>88</strong></td><td style="text-align:center">72</td><td style="text-align:center">85</td><td style="text-align:center">42</td><td style="text-align:center">83</td><td style="text-align:center">73</td><td style="text-align:center"><strong>48</strong></td><td style="text-align:center"><strong>锁定交换数字</strong></td></tr><tr><td style="text-align:center">pivot</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"><strong>left</strong></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"><strong>right</strong></td><td style="text-align:center">（<strong>右指针先动</strong>）</td></tr><tr><td style="text-align:center"><strong>60</strong></td><td style="text-align:center">6</td><td style="text-align:center">57</td><td style="text-align:center"><strong>48</strong></td><td style="text-align:center">72</td><td style="text-align:center">85</td><td style="text-align:center">42</td><td style="text-align:center">83</td><td style="text-align:center">73</td><td style="text-align:center"><strong>88</strong></td><td style="text-align:center"><strong>交换数字</strong></td></tr><tr><td style="text-align:center">pivot</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">left</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">right</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>60</strong></td><td style="text-align:center">6</td><td style="text-align:center">57</td><td style="text-align:center">48</td><td style="text-align:center"><strong>72</strong></td><td style="text-align:center">85</td><td style="text-align:center"><strong>42</strong></td><td style="text-align:center">83</td><td style="text-align:center">73</td><td style="text-align:center">88</td><td style="text-align:center"><strong>锁定交换数字</strong></td></tr><tr><td style="text-align:center">pivot</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"><strong>left</strong></td><td style="text-align:center"></td><td style="text-align:center"><strong>right</strong></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">（<strong>右指针先动</strong>）</td></tr><tr><td style="text-align:center"><strong>60</strong></td><td style="text-align:center">6</td><td style="text-align:center">57</td><td style="text-align:center">48</td><td style="text-align:center"><strong>42</strong></td><td style="text-align:center">85</td><td style="text-align:center"><strong>72</strong></td><td style="text-align:center">83</td><td style="text-align:center">73</td><td style="text-align:center">88</td><td style="text-align:center"><strong>交换数字</strong></td></tr><tr><td style="text-align:center">pivot</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">left</td><td style="text-align:center"></td><td style="text-align:center">right</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>60</strong></td><td style="text-align:center">6</td><td style="text-align:center">57</td><td style="text-align:center">48</td><td style="text-align:center"><strong>42</strong></td><td style="text-align:center">85</td><td style="text-align:center">72</td><td style="text-align:center">83</td><td style="text-align:center">73</td><td style="text-align:center">88</td><td style="text-align:center"><strong>终止条件达成</strong></td></tr><tr><td style="text-align:center">pivot</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"><strong>left</strong>, <strong>right</strong></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">（<strong>右指针先动</strong>）</td></tr><tr><td style="text-align:center"><strong>42</strong></td><td style="text-align:center">6</td><td style="text-align:center">57</td><td style="text-align:center">48</td><td style="text-align:center"><strong>60</strong></td><td style="text-align:center">85</td><td style="text-align:center">72</td><td style="text-align:center">83</td><td style="text-align:center">73</td><td style="text-align:center">88</td><td style="text-align:center"><strong>终止</strong></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"><strong>left</strong>, right, pivot</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"><strong>还原pivot</strong></td></tr></tbody></table></div><hr><p>对[42, 6, 57, 48]，[85, 72, 83, 73, 88]进行划分。</p><p>左侧pivot为42，正好在begin处；右侧pivot为85，也正好在begin处。</p><div class="table-container"><table><thead><tr><th style="text-align:center">42</th><th style="text-align:center">6</th><th style="text-align:center">57</th><th style="text-align:center">48</th><th style="text-align:center">60</th><th style="text-align:center">85</th><th style="text-align:center">72</th><th style="text-align:center">83</th><th style="text-align:center">73</th><th style="text-align:center">88</th><th style="text-align:center">初始化</th></tr></thead><tbody><tr><td style="text-align:center">pivot1, left</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">right</td><td style="text-align:center">-</td><td style="text-align:center">pivot2, left</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">right</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>42</strong></td><td style="text-align:center"><strong>6</strong></td><td style="text-align:center">57</td><td style="text-align:center">48</td><td style="text-align:center">60</td><td style="text-align:center"><strong>85</strong></td><td style="text-align:center">72</td><td style="text-align:center">83</td><td style="text-align:center"><strong>73</strong></td><td style="text-align:center">88</td><td style="text-align:center"><strong>终止条件达成</strong></td></tr><tr><td style="text-align:center">pivot1</td><td style="text-align:center"><strong>left, right</strong></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">-</td><td style="text-align:center">pivot2</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"><strong>left, right</strong></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>6</strong></td><td style="text-align:center"><strong>42</strong></td><td style="text-align:center">57</td><td style="text-align:center">48</td><td style="text-align:center">60</td><td style="text-align:center"><strong>73</strong></td><td style="text-align:center">72</td><td style="text-align:center">83</td><td style="text-align:center"><strong>85</strong></td><td style="text-align:center">88</td><td style="text-align:center"><strong>终止</strong></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><strong>left</strong>, right, pivot1</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">-</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"><strong>left</strong>, right, pivot2</td><td style="text-align:center"></td><td style="text-align:center"><strong>还原各自的pivot</strong></td></tr></tbody></table></div><hr><p>[6], [88]不用划分，对[57, 48]，[72, 73, 83]划分：前者pivot=57，后者pivot=73，正好都在begin处。</p><div class="table-container"><table><thead><tr><th style="text-align:center">6</th><th style="text-align:center">42</th><th style="text-align:center">57</th><th style="text-align:center">48</th><th style="text-align:center">60</th><th style="text-align:center">73</th><th style="text-align:center">72</th><th style="text-align:center">83</th><th style="text-align:center">85</th><th style="text-align:center">88</th><th style="text-align:center">初始化</th></tr></thead><tbody><tr><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">pivot1, left</td><td style="text-align:center">right</td><td style="text-align:center">-</td><td style="text-align:center">pivot2, left</td><td style="text-align:center"></td><td style="text-align:center">right</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">42</td><td style="text-align:center">57</td><td style="text-align:center"><strong>48</strong></td><td style="text-align:center">60</td><td style="text-align:center"><strong>73</strong></td><td style="text-align:center">72</td><td style="text-align:center">83</td><td style="text-align:center">85</td><td style="text-align:center">88</td><td style="text-align:center"><strong>终止条件达成</strong></td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">pivot1</td><td style="text-align:center"><strong>left, right</strong></td><td style="text-align:center">-</td><td style="text-align:center">pivot2</td><td style="text-align:center"><strong>left, right</strong></td><td style="text-align:center"></td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">42</td><td style="text-align:center"><strong>48</strong></td><td style="text-align:center"><strong>57</strong></td><td style="text-align:center">60</td><td style="text-align:center"><strong>72</strong></td><td style="text-align:center"><strong>73</strong></td><td style="text-align:center">83</td><td style="text-align:center">85</td><td style="text-align:center">88</td><td style="text-align:center"><strong>终止</strong></td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center"></td><td style="text-align:center"><strong>left</strong>, right, pivot1</td><td style="text-align:center">-</td><td style="text-align:center"></td><td style="text-align:center"><strong>left</strong>, right, pivot2</td><td style="text-align:center"></td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center"><strong>还原各自的pivot</strong></td></tr></tbody></table></div><p>至此，排序完成。</p><p>最终序列为：</p><p>6 42 48 57 60 73 75 83 85 88</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_pivot</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 返回arr[begin], arr[mid], arr[end]的中间值</span></span><br><span class="line">    <span class="keyword">int</span> mid = (begin + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[begin] &lt; arr[end]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[end] &lt; arr[mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> end;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[begin] &gt; arr[mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> begin;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[end] &gt; arr[mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> end;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[begin] &lt; arr[mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> begin;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot_index = find_pivot(arr, begin, end);</span><br><span class="line">    swap(arr[begin], arr[pivot_index]); <span class="comment">// 将pivot置于begin处</span></span><br><span class="line">    <span class="keyword">int</span> left = begin;</span><br><span class="line">    <span class="keyword">int</span> right = end;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= arr[begin]) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= arr[begin]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            swap(arr[left], arr[right]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            swap(arr[left], arr[begin]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (begin &gt;= end) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> pivotIdx = partition(arr, begin, end);</span><br><span class="line">        quick_sort(arr, begin, pivotIdx - <span class="number">1</span>); <span class="comment">// 对左序列重新排序</span></span><br><span class="line">        quick_sort(arr, pivotIdx + <span class="number">1</span>, end); <span class="comment">// 对右序列重新排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">72</span>, <span class="number">6</span>, <span class="number">57</span>, <span class="number">88</span>, <span class="number">60</span>, <span class="number">85</span>, <span class="number">42</span>, <span class="number">83</span>, <span class="number">73</span>, <span class="number">48</span>&#125;;</span><br><span class="line">    quick_sort(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; nums[i] &lt;&lt; <span class="string">' '</span> &lt;&lt; ends;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>思想：binary heap就是一种完全二叉树，每个节点的值均大于等于其子节点的值。</p><p>静态版（大顶堆）：</p><div align=center><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200304175428.jpg"></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HEAP</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> heapSize;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; harr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HEAP() &#123;</span><br><span class="line">        heapSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    HEAP(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator begin, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator end) &#123;</span><br><span class="line">        heapSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = begin; it != end; it++) &#123;</span><br><span class="line">            insert(*it);      </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heapSize; i++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; harr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        harr.push_back(num); <span class="comment">// 将新数插入至末尾</span></span><br><span class="line">        heapSize++;</span><br><span class="line">        <span class="keyword">int</span> idx = heapSize - <span class="number">1</span>; <span class="comment">// 取新数的索引</span></span><br><span class="line">        <span class="keyword">while</span> (idx &gt;= <span class="number">0</span> &amp;&amp; harr[parent(idx)] &gt; harr[idx]) &#123; <span class="comment">// 将新数交换至正确的位置</span></span><br><span class="line">            swap(harr[parent(idx)], harr[idx]);</span><br><span class="line">            idx = parent(idx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heapSize; i++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; harr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">minheapify</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> boundry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftIdx = left(idx); <span class="comment">// 取idx左边子节点</span></span><br><span class="line">        <span class="keyword">int</span> rightIdx = right(idx); <span class="comment">// 取idx右边子节点</span></span><br><span class="line">        <span class="keyword">if</span> (leftIdx &gt;= boundry || rightIdx &gt;= boundry) &#123; <span class="comment">// 判断剩余元素是否已经成堆</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> minIdx = idx; <span class="comment">// 记录最小元素的索引</span></span><br><span class="line">        <span class="keyword">if</span> (harr[leftIdx] &lt; harr[idx]) &#123;</span><br><span class="line">            minIdx = leftIdx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (harr[rightIdx] &lt; harr[minIdx]) &#123;</span><br><span class="line">            minIdx = rightIdx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minIdx != idx) &#123;</span><br><span class="line">            swap(harr[idx], harr[minIdx]);</span><br><span class="line">            minheapify(minIdx, boundry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sort() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; heapSize - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            swap(harr[<span class="number">0</span>], harr[heapSize - i]); <span class="comment">// 每次将最小元素移到后面去（移出堆中）</span></span><br><span class="line">            minheapify(<span class="number">0</span>, heapSize - i); <span class="comment">// 将剩下的元素重新调节成最小堆</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (harr[<span class="number">0</span>] &lt; harr[<span class="number">1</span>]) &#123;</span><br><span class="line">            swap(harr[<span class="number">0</span>], harr[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> harr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>思想：空间换取时间，计算每个数的次数，最后遍历并存入原数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">counting_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxNum = INT_MIN;</span><br><span class="line">    <span class="keyword">int</span> size = arr.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        maxNum = max(maxNum, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> range = maxNum + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp(range, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123; <span class="comment">// 计数</span></span><br><span class="line">        ++temp[arr[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>; i &lt; range; i++) &#123; <span class="comment">// 遍历每个数槽</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; temp[i]; k++) &#123; <span class="comment">// 取出该数，直到达到之前的计数</span></span><br><span class="line">            arr[++j] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化：创建<code>max-min+1</code>个空间，减少空间浪费</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">counting_sort_op</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxNum = INT_MIN;</span><br><span class="line">    <span class="keyword">int</span> minNum = INT_MAX;</span><br><span class="line">    <span class="keyword">int</span> size = arr.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        maxNum = max(maxNum, arr[i]);</span><br><span class="line">        minNum = min(minNum, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> range = maxNum - minNum + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp(range, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        temp[arr[i]-minNum]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>; i &lt; range; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; temp[i]; k++) &#123;</span><br><span class="line">            arr[++j] = i + minNum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>思想：分治法，桶排序是计数排序的扩展版本，计数排序可以看成每个桶只存储相同元素，桶排序每个桶存储一定范围的元素，通过映射函数，将待排序数组中的元素映射到各个对应的桶中，对每个桶中的元素进行排序，最后将非空桶中的元素逐个放入原序列中。</p><p>静态版：</p><div align=center><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200303234808.png"></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucket_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = arr.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp[size];</span><br><span class="line">    <span class="keyword">int</span> maxNum = INT_MIN;</span><br><span class="line">    <span class="keyword">int</span> minNum = INT_MAX;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123; <span class="comment">// 确定最大最小值</span></span><br><span class="line">        maxNum = max(maxNum, arr[i]);</span><br><span class="line">        minNum = min(minNum, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> bucketNum = (<span class="keyword">int</span>)(arr[i] - minNum) / (maxNum - minNum + <span class="number">1</span>) * size; <span class="comment">// 加1是为了确保bucketNum &lt; size</span></span><br><span class="line">        temp[bucketNum].push_back(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123; <span class="comment">// 将每个桶内排序</span></span><br><span class="line">        sort(temp[i].begin(), temp[i].end());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123; <span class="comment">// 按序将桶内排好序的数字拷回arr</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; temp[i].size(); j++) &#123;</span><br><span class="line">            arr[idx++] = temp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>思想：首先了解分配排序(binsort)，即创建数组A[MaxValue]；然后将每个数放到相应的位置上（例如17放在下标17的数组位置）；最后遍历数组，即为排序后的结果。</p><p>静态版：</p><div align=center><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200304005951.jpg"></div><p>问题在于，当序列中的元素分布不集中时，会造成大量的空间开销。</p><p>基数排序即在此基础上，通过基数的限制减少空间开销。</p><p>静态版：</p><div align=center><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200304010131.jpg"></div><div align=center><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200304010147.jpg"></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> <span class="built_in">exp</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = arr.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp(size, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123; <span class="comment">// 计算在第exp位的每个数字出现的次数</span></span><br><span class="line">        count[(arr[i] / <span class="built_in">exp</span>) % <span class="number">10</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">// 计算累计数量</span></span><br><span class="line">        count[i] += count[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; </span><br><span class="line">        temp[count[(arr[i] / <span class="built_in">exp</span>) % <span class="number">10</span>] - <span class="number">1</span>] = arr[i];</span><br><span class="line">        count[(arr[i] / <span class="built_in">exp</span>) % <span class="number">10</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  arr = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radix_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxNum = INT_MIN;</span><br><span class="line">    <span class="keyword">int</span> size = arr.size();</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">exp</span> = <span class="number">0</span>; <span class="comment">// 记录最大数的位数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        maxNum = max(maxNum, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">exp</span> = <span class="number">1</span>; maxNum / <span class="built_in">exp</span> &gt; <span class="number">0</span>; <span class="built_in">exp</span> *= <span class="number">10</span>) &#123;</span><br><span class="line">        count_sort(arr, <span class="built_in">exp</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;&gt;&lt;/a&gt;排序算法&lt;/h2&gt;&lt;p&gt;Playground在线运行地址：&lt;a href=&quot;https://leetcode-cn.com/playground/rKzLfEEY/&quot;&gt;https://leetcode-cn.com/playground/rKzLfEEY/&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;排序算法&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;平均时间复杂度&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;最好情况&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;最坏情况&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;空间复杂度&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;排序方式&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;稳定性&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;冒泡排序&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(n^2)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(n)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(n^2)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(1)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;In-place&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;稳定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;选择排序&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(n^2)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(n^2)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(n^2)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(1)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;In-place&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;不稳定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;插入排序&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(n^2)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(n)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(n^2)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(1)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;In-place&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;稳定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;希尔排序&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(nlogn)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(nlogn)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(nlogn)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(1)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;In-place&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;不稳定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;归并排序&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(nlogn)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(nlogn)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(nlogn)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(n)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Out-place&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;稳定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;快速排序&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(nlogn)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(nlogn)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(n^2)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(logn)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;In-place&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;不稳定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;堆排序&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(nlogn)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(nlogn)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(nlogn)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(1)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;In-place&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;不稳定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;计数排序&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(n+k)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(n+k)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(n+k)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(k)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Out-place&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;稳定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;桶排序&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(n+k)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(n+k)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(n^2)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(n+k)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Out-place&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;稳定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;基数排序&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(n×k)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(n×k)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(n×k)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$O(n+k)$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Out-place&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;稳定&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="C++" scheme="https://www.jiangluyu.xyz/categories/C/"/>
    
      <category term="LeetCode" scheme="https://www.jiangluyu.xyz/categories/C/LeetCode/"/>
    
    
      <category term="算法" scheme="https://www.jiangluyu.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="https://www.jiangluyu.xyz/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer</title>
    <link href="https://www.jiangluyu.xyz/2022/02/21/%E5%89%91%E6%8C%87Offer/"/>
    <id>https://www.jiangluyu.xyz/2022/02/21/剑指Offer/</id>
    <published>2022-02-20T16:32:00.000Z</published>
    <updated>2022-02-22T18:21:18.117Z</updated>
    
    <content type="html"><![CDATA[<p>分类整理剑指Offer题目思路。</p><a id="more"></a><h2 id="栈-amp-队列"><a href="#栈-amp-队列" class="headerlink" title="栈&amp;队列"></a>栈&amp;队列</h2><h3 id="E09-用两个队列实现栈"><a href="#E09-用两个队列实现栈" class="headerlink" title="E09 用两个队列实现栈"></a>E09 用两个队列实现栈</h3><p>创建栈A和栈B，栈A负责push，栈B负责接收栈A所有元素后pop。</p><hr><h3 id="E30-包含min函数的栈"><a href="#E30-包含min函数的栈" class="headerlink" title="E30 包含min函数的栈"></a>E30 包含min函数的栈</h3><p>创建一个辅助栈，每次主栈push/pop操作时同时push/pop当前最小值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // std::min()</span></span></span><br></pre></td></tr></table></figure><hr><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="E06-从尾到头打印链表"><a href="#E06-从尾到头打印链表" class="headerlink" title="E06 从尾到头打印链表"></a>E06 从尾到头打印链表</h3><p>用vector遍历，再reverse。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reverse(<span class="built_in">vector</span>.begin(), <span class="built_in">vector</span>.end())</span><br></pre></td></tr></table></figure><hr><h3 id="E24-反转链表"><a href="#E24-反转链表" class="headerlink" title="E24 反转链表"></a>E24 反转链表</h3><p><strong>遍历：</strong></p><p>​    创建prev，curr，temp三个结点，初始prev=NULL，curr=head，temp=NULL。</p><p>用temp保存curr-&gt;next，令curr-&gt;next=prev，prev=curr，curr=temp，直到curr为NULL。</p><p><strong>递归：</strong></p><p>​    中间处理：类似1-&gt;2-&gt;3 =&gt; 1-&gt;2-&gt;3-&gt;2 =&gt; 1-&gt;2&lt;-3</p><p>​    终结条件：head == NULL || head -&gt; next == NULL</p><p>​    处理步骤：head -&gt; next -&gt; next = head;</p><p>​                      head -&gt; next = NULL</p><hr><h3 id="M35-复杂链表的复制"><a href="#M35-复杂链表的复制" class="headerlink" title="M35 复杂链表的复制"></a>M35 复杂链表的复制</h3><p>迭代+节点拆分：</p><p>​    A-&gt;A’-&gt;B-&gt;B’-&gt;C-&gt;C’，遍历三次</p><p>第一次遍历：从A-&gt;B-&gt;C形成A-&gt;A’-&gt;B-&gt;B’-&gt;C-&gt;C’</p><p>第二次遍历：使得A’, B’, C’的random指向对应的node</p><p>第三次遍历：剥离A’-&gt;B’-&gt;C’，恢复原来的A-&gt;B-&gt;C</p><hr><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="E05-替换空格"><a href="#E05-替换空格" class="headerlink" title="E05 替换空格"></a>E05 替换空格</h3><p><strong>创建新数组：</strong></p><p>时间空间均为O(N)。</p><p><strong>原地修改：</strong></p><p>（C++ string可变）</p><p>统计空格数 -&gt; 扩展string长度 str.resize() -&gt; 倒序插入，left指向原字符串末尾，right指向新字符串末尾，如果str[left] == ‘ ‘，str[right~rigfht-2]替换为%20，right-=2，否则复制str[left]内容。</p><p>空间O(1)，时间O(N)。</p><hr><h3 id="E58-2-左旋转字符串"><a href="#E58-2-左旋转字符串" class="headerlink" title="E58-2 左旋转字符串"></a>E58-2 左旋转字符串</h3><p><strong>允许额外空间：</strong></p><p>return (s+s).substr(n, s.size());</p><p><strong>不允许额外空间：</strong></p><p>三次旋转：整体旋转+前半段n旋转+后半段旋转，reverse()</p><hr><h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><h3 id="E03-数组中的重复数字"><a href="#E03-数组中的重复数字" class="headerlink" title="E03 数组中的重复数字"></a>E03 数组中的重复数字</h3><p><strong>哈希表：</strong></p><p>unordered_map<int, bool>记录</p><p><strong>原地交换：</strong></p><p>1~n-1的数字，意味着一对多的映射。</p><p>遍历，当nums[i] == i时，递增；</p><p>如果nums[nums[i]] = i，即两个数字相等，则break，</p><p>否则交换nums[i]和nums[nums[i]]，重新比较nums[i]与i是否满足继续向后的条件。</p><hr><h3 id="E53-1-在排序数组中查找数字"><a href="#E53-1-在排序数组中查找数字" class="headerlink" title="E53-1 在排序数组中查找数字"></a>E53-1 在排序数组中查找数字</h3><p><strong>看到排序数组一般想到二分：</strong></p><p>两次二分法：第一次找左边界，第二次找右边界。</p><p>这里可以优化：找target&amp;target-1（是否在数组里不重要），返回right index，结果为bs(target) - bs(target - 1 )</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 想不清楚可以举个简单例子画图</span></span><br><span class="line">    <span class="comment">// 注意'/'向下取整</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 没找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="E53-2-0-n-1中缺失的数字"><a href="#E53-2-0-n-1中缺失的数字" class="headerlink" title="E53-2 0~n-1中缺失的数字"></a>E53-2 0~n-1中缺失的数字</h3><p>排序数组首先考虑二分</p><p>nums[mid] == mid时，说明缺失值在[mid + 1, right]</p><p>nums[mid] &gt; mid时，说明缺失值在[left, mid]</p><p>最终返回right + 1即可，本题也可以返回left。</p><hr><h3 id="M04-二维数组中的查找"><a href="#M04-二维数组中的查找" class="headerlink" title="M04 二维数组中的查找"></a>M04 二维数组中的查找</h3><p><strong>暴力：</strong></p><p>面试官：“今天就到这里吧:monkey:”</p><p><strong>“二分”：</strong></p><p>一开始想到按行二分，后来看到更好的类似二维二分的方法</p><p>由于矩阵中行列的递增性，可以从右上角开始搜索，若M[row][col] &gt; target，则col—；若M[row][col] &lt; target，则row++</p><p>需要注意的是，有个奇怪的边界输入：[]</p><hr><h3 id="E11-旋转数组的最小数字"><a href="#E11-旋转数组的最小数字" class="headerlink" title="E11 旋转数组的最小数字"></a>E11 旋转数组的最小数字</h3><p>包含两个非降序，同样可以考虑二分法</p><p>如果mid处值&gt;最右端点处，说明最小值点在mid右边</p><p>如果mid处值&lt;最右端点处，说明最小值点在mid左边，此时mid处也有可能是最小值，所以不能right = mid - 1，而要right=mid</p><p>如果mid处值=最右端点处，有重复值，说明最右端点可以忽略</p><p>返回时此时有可能mid处 = right处，导致right—，而最小值在mid处，所以return numbers[left]</p><hr><h3 id="E50-第一个只出现一次的字符"><a href="#E50-第一个只出现一次的字符" class="headerlink" title="E50 第一个只出现一次的字符"></a>E50 第一个只出现一次的字符</h3><p>第一感觉：<strong>标记法：</strong></p><p>unordered_map<char, int/bool></p><p><strong>当字符串很长的时候：</strong></p><p>unordered_map<char, int/bool></p><p>vector\<char>记录插入map中的顺序</p><p><strong>队列：</strong></p><p>用队列维护第一个只出现一次的元素</p><div class="table-container"><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>front()</td><td>返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。</td></tr><tr><td>back()</td><td>返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。</td></tr><tr><td>push(const T&amp; obj)</td><td>在 queue 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 push_back() 来完成的。</td></tr><tr><td>push(T&amp;&amp; obj)</td><td>以移动的方式在 queue 的尾部添加元素。这是通过调用底层容器的具有右值引用参数的成员函数 push_back() 来完成的。</td></tr><tr><td>pop()</td><td>删除 queue 中的第一个元素。</td></tr><tr><td>size()</td><td>返回 queue 中元素的个数。</td></tr><tr><td>empty()</td><td>如果 queue 中没有元素的话，返回 true。</td></tr><tr><td>emplace()</td><td>用传给 emplace() 的参数调用 T 的构造函数，在 queue 的尾部生成对象。</td></tr></tbody></table></div><hr><h2 id="搜索与回溯算法"><a href="#搜索与回溯算法" class="headerlink" title="搜索与回溯算法"></a>搜索与回溯算法</h2><h3 id="M32-1-从上到下打印二叉树"><a href="#M32-1-从上到下打印二叉树" class="headerlink" title="M32-1 从上到下打印二叉树"></a>M32-1 从上到下打印二叉树</h3><p>按题意即为广度优先搜索，BFS优先考虑<strong>队列</strong>：</p><p>题目不难，这里讲讲queue和deque的区别：</p><p>queue双端都能访问，deque（double-ended queue）亦然，deque的特点是两端都能插入、弹出，而queue只能在首端弹出、末端插入，因而deque在api上区分了push_front(), push_back(), pop_front(), pop_back()</p><hr><h3 id="E32-2-从上到下打印二叉树II"><a href="#E32-2-从上到下打印二叉树II" class="headerlink" title="E32-2 从上到下打印二叉树II"></a>E32-2 从上到下打印二叉树II</h3><p>和M32-1的区别在于要将每一行对应数组的一行</p><p><strong>多加个标号：</strong></p><p>queue<pair<TreeNode*, int>&gt;</p><p>需要注意如果ans.size() &lt; vectorIdx + 1，那么先要创建空vector插入ans尾部</p><p>其余与M32-1代码结构基本不变</p><p><strong>用q.size()来作为循环次数：</strong></p><p>套一层for循环，用vectorTemp记录该层的vals</p><hr><h3 id="M32-3-从上到下打印二叉树III"><a href="#M32-3-从上到下打印二叉树III" class="headerlink" title="M32-3 从上到下打印二叉树III"></a>M32-3 从上到下打印二叉树III</h3><p><strong>多个ans.size()判断：</strong></p><p>根据ans的size来判断是奇数行还是偶数行，对vecTemp进行reverse即可</p><p><strong>用deque：</strong></p><p>奇数行node用push_back，偶数行node用push_front</p><hr><h3 id="M26-树的子结构"><a href="#M26-树的子结构" class="headerlink" title="M26 树的子结构"></a>M26 树的子结构</h3><p>输入两棵二叉树A和B，判断B是不是A的子结构（空树不是任意树的子结构）</p><p><strong>这题思路比较精彩，用前序遍历+递归：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A == <span class="literal">nullptr</span> || B == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> recur(A, B) || isSubStructure(A-&gt;left, B) || isSubStructure(A-&gt;right, B);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">recur</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (B == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (A == <span class="literal">nullptr</span> || A-&gt;val != B-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> recur(A-&gt;left, B-&gt;left) &amp;&amp; recur(A-&gt;right, B-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与B相等的结构要么是A树本身，要么是A的左子树（的左子树……递归），要么是A的右子树（的右子树…递归）</p><p>贴个帖子：<a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/solution/yi-pian-wen-zhang-dai-ni-chi-tou-dui-che-uhgs/">一篇文章吃透对称性递归</a></p><hr><h3 id="E27-二叉树的镜像"><a href="#E27-二叉树的镜像" class="headerlink" title="E27 二叉树的镜像"></a>E27 二叉树的镜像</h3><p><strong>很好理解的递归：（自下而上交换）</strong></p><p>如果一个节点的左或右节点有子节点，那么继续往下探，直至不满足时，也就是找到了叶节点的父节点，此时交换左右节点</p><p>注意边界条件，树的存在性</p><p><strong>迭代：queue（自上而下交换）</strong></p><p>把父节点左右节点交换之后，把左右节点也插入队列，如果节点为空就跳过，否则继续重复这个动作</p><hr><h3 id="E28-对称的二叉树"><a href="#E28-对称的二叉树" class="headerlink" title="E28 对称的二叉树"></a>E28 对称的二叉树</h3><p><strong>递归：</strong></p><p>对称的二叉树满足的条件为左子树的左节点 = 右子树的右节点，从上往下递归</p><p>故对于root来说，只需要比较root-&gt;left，root-&gt;right，对于递归函数来说，只需要继续比较root-&gt;left-&gt;left，root-&gt;right-&gt;right以及root-&gt;left-&gt;right，root-&gt;right-&gt;left</p><hr><h3 id="M12-矩阵中的路径"><a href="#M12-矩阵中的路径" class="headerlink" title="M12 矩阵中的路径"></a>M12 矩阵中的路径</h3><p><strong>递归</strong>：</p><p>对网格中的每个字母都进行从word[0]开始的dfs，如果满足，则将该位置置为’\0’，继续向上下左右探，返回前修改回word[pos]即可</p><hr><h3 id="M13-机器人的运动范围"><a href="#M13-机器人的运动范围" class="headerlink" title="M13 机器人的运动范围"></a>M13 机器人的运动范围</h3><p><strong>递归</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        row_max = m - <span class="number">1</span>;</span><br><span class="line">        col_max = n - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; flag(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, k, ans, flag);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> row_max;</span><br><span class="line">    <span class="keyword">int</span> col_max;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calc_sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (a) &#123;</span><br><span class="line">            res += a % <span class="number">10</span>;</span><br><span class="line">            a /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (b) &#123;</span><br><span class="line">            res += b % <span class="number">10</span>;</span><br><span class="line">            b /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> k, <span class="keyword">int</span>&amp; sum, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt; row_max || col &lt; <span class="number">0</span> || col &gt; col_max || k &lt; calc_sum(row, col) || flag[row][col]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum++;</span><br><span class="line">        flag[row][col] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        dfs(row + <span class="number">1</span>, col, k, sum, flag);</span><br><span class="line">        dfs(row, col + <span class="number">1</span>, k, sum, flag);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注：和M12基本框架一致，注意二维vector的初始化方式及传参方式，及calc_sum的实现方式</p><hr><h3 id="M34-二叉树中和为某一值的路径"><a href="#M34-二叉树中和为某一值的路径" class="headerlink" title="M34 二叉树中和为某一值的路径"></a>M34 二叉树中和为某一值的路径</h3><p><strong>递归</strong>：</p><p>深度优先搜索，每当达到叶节点时即计算路径和，若等于target则记录，否则往回退，删除当前节点值</p><p>回溯的基本思路一致</p><hr><h3 id="M36-二叉搜索树与双向链表"><a href="#M36-二叉搜索树与双向链表" class="headerlink" title="M36 二叉搜索树与双向链表"></a>M36 二叉搜索树与双向链表</h3><p><strong>递归</strong>：</p><p>BST所以中序遍历可以保证递增，注意题目要求最好就地（实测用vector也通过了）</p><p>注意可以用全局变量来记录prev&amp;head，当dfs结束时，head为首，prev为末，让其完成双向循环链表</p><hr><h3 id="E54-二叉搜索树的第k大节点"><a href="#E54-二叉搜索树的第k大节点" class="headerlink" title="E54 二叉搜索树的第k大节点"></a>E54 二叉搜索树的第k大节点</h3><p><strong>递归</strong>：</p><p>后序遍历，找到第k个值即返回</p><hr><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="E10-1-斐波那契数列"><a href="#E10-1-斐波那契数列" class="headerlink" title="E10-1 斐波那契数列"></a>E10-1 斐波那契数列</h3><p><strong>递归：不谈</strong></p><p><strong>动态规划：</strong>申请一个n+1长度的vector，注意类型int不够，dp[i] = dp[i-1] + dp[i-2]；</p><p><strong>动态规划改进：</strong>仅更新三个数字a, b, sum即可，因为前面的计算过程无需再用到</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    sum = (a + b) % <span class="number">1000000007</span>;</span><br><span class="line">    a = b;</span><br><span class="line">    b = sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br></pre></td></tr></table></figure><hr><h3 id="E10-2-青蛙跳台阶问题"><a href="#E10-2-青蛙跳台阶问题" class="headerlink" title="E10-2 青蛙跳台阶问题"></a>E10-2 青蛙跳台阶问题</h3><p><strong>动态规划</strong>：想清楚n阶的方法数 = n-1阶的方法数+n-2阶的方法数，即初始值为1, 1的斐波那契数列</p><hr><h3 id="M63-股票的最大利润"><a href="#M63-股票的最大利润" class="headerlink" title="M63 股票的最大利润"></a>M63 股票的最大利润</h3><p><strong>动态规划</strong>：贴个链接：<a href="http://www.jiangluyu.xyz/2020/03/09/%E5%85%AD%E9%81%93%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/">六道股票问题</a></p><hr><h3 id="E42-连续子数组的最大和"><a href="#E42-连续子数组的最大和" class="headerlink" title="E42 连续子数组的最大和"></a>E42 连续子数组的最大和</h3><p><strong>动态规划</strong>：</p><p>基础状态：</p><script type="math/tex; mode=display">dp[0] = nums[0]</script><p>状态转移方程：</p><script type="math/tex; mode=display">dp[i] = \begin{cases}dp[i-1] + nums[i], dp[i-1] \ge 0 \\nums[i], dp[i-1] \lt 0 \\\end{cases}</script><hr><h3 id="M47-礼物的最大价值"><a href="#M47-礼物的最大价值" class="headerlink" title="M47 礼物的最大价值"></a>M47 礼物的最大价值</h3><p><strong>动态规划</strong>：</p><p>基础状态：</p><script type="math/tex; mode=display">dp[0][0] = grid[0][0]</script><p>状态转移方程：</p><script type="math/tex; mode=display">dp[i][j] = \begin{cases}dp[i][j - 1] + grid[i][j], i = 0, j > 0 \\dp[i - 1][j] + grid[i][j], j = 0, i > 0 \\max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j], i > 0, j > 0\end{cases}</script><hr><h3 id="M46-把数字翻译成字符串"><a href="#M46-把数字翻译成字符串" class="headerlink" title="M46 把数字翻译成字符串"></a>M46 把数字翻译成字符串</h3><p><strong>动态规划</strong>：注意06只能翻译为’af’，0无法参与组合</p><p>基础状态：</p><script type="math/tex; mode=display">dp[0] = dp[1] = 1</script><p>状态转移方程：</p><script type="math/tex; mode=display">dp[i] = \begin{cases}dp[i - 1], atoi(num.substr(i - 1, 2).c\_str) \ge 26 || num[i - 1] - '0' = 0, i \ge 2 \\dp[i - 1] + dp[i - 2], atoi(num.substr(i - 1, 2).c\_str) \lt 26 \&\& num[i - 1] - '0' \ne 0, i \ge 2 \\\end{cases}</script><hr><h3 id="M48-最长不含重复字符的子字符串"><a href="#M48-最长不含重复字符的子字符串" class="headerlink" title="M48 最长不含重复字符的子字符串"></a>M48 最长不含重复字符的子字符串</h3><p><strong>动态规划</strong>：</p><p>基础状态：</p><script type="math/tex; mode=display">dp[0] = 1</script><p>状态转移方程：</p><script type="math/tex; mode=display">dp[i] = \begin{cases}dp[i - 1] + 1, if \ s[i]\  never \ shows \ up \\min(dp[i - 1] + 1, i - map[s[i]]), if \ s[i] showed \ up \ before)\end{cases}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; refs;</span><br><span class="line">refs.count(s[i]) == <span class="number">0</span>; <span class="comment">//是否出现过</span></span><br></pre></td></tr></table></figure><hr><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="E18-删除链表的节点"><a href="#E18-删除链表的节点" class="headerlink" title="E18 删除链表的节点"></a>E18 删除链表的节点</h3><p><strong>双指针</strong>：注意如果head是要删除的节点，直接返回head-&gt;next</p><p>定义prev&amp;curr，如果curr是要删除的节点，则令prev-&gt;next = curr-&gt;next</p><hr><h3 id="E22-链表中倒数第k个节点"><a href="#E22-链表中倒数第k个节点" class="headerlink" title="E22 链表中倒数第k个节点"></a>E22 链表中倒数第k个节点</h3><p><strong>双指针</strong>：</p><p>定义high&amp;low，让high先走k步，再让两者一起前进，直到high为nullptr，则返回low</p><p><strong>队列</strong>：</p><p>检查队列的size为k，全部push结束后，queue.front()即为答案</p><hr><h3 id="E25-合并两个排序的列表"><a href="#E25-合并两个排序的列表" class="headerlink" title="E25 合并两个排序的列表"></a>E25 合并两个排序的列表</h3><p><strong>哈希表</strong>：</p><p>遍历A，再遍历B，查询哈希表内有无出现过A的节点</p><p><strong>双指针</strong>：</p><p>使用一个dummy node作为head，curr node标记当前位置。l1与l2中小的即作为curr-&gt;next，随后curr与l1/l2中的一个往后移动，直至有一方为null，curr-&gt;next把非空的剩下部分作为尾巴接上</p><hr><h3 id="E52-两个链表的第一个公共节点"><a href="#E52-两个链表的第一个公共节点" class="headerlink" title="E52 两个链表的第一个公共节点"></a>E52 两个链表的第一个公共节点</h3><p><strong>双指针</strong>：</p><p>浪漫相遇，如果A走到头为null时，next为headB，B同理，直到它们相等，要么为相遇的第一个点，要么为null</p><hr><h3 id="E21-调整数组顺序使奇数位于偶数前面"><a href="#E21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="E21 调整数组顺序使奇数位于偶数前面"></a>E21 调整数组顺序使奇数位于偶数前面</h3><p><strong>双指针</strong>：</p><p>left从左往右搜索偶数，right从右往左搜索奇数，如越界或right&lt;left则直接返回nums，否则交换，并继续</p><hr><h3 id="E57-和为s的两个数字"><a href="#E57-和为s的两个数字" class="headerlink" title="E57 和为s的两个数字"></a>E57 和为s的两个数字</h3><p><strong>双指针</strong>：</p><p>left从左往右，right从右往左，若sum &lt; target，则left++，若sum &gt; target，则right—，越界或left&gt;=right则停止</p><hr><h3 id="E58-1-翻转单词顺序"><a href="#E58-1-翻转单词顺序" class="headerlink" title="E58-1 翻转单词顺序"></a>E58-1 翻转单词顺序</h3><p><strong>双指针</strong>：</p><p>j从右往左，找到第一个非空格字符（注意j&gt;=0），如果此时j小于0了，结束；i从j开始从右往左（同样i&gt;=0），找到第一个空格，将从i+1开始的j-i个字符添加到ans中（再加个空格），令i=j，重复至停止</p><hr><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="M45-把数组排成最小的数"><a href="#M45-把数组排成最小的数" class="headerlink" title="M45 把数组排成最小的数"></a>M45 把数组排成最小的数</h3><p><strong>排序：</strong></p><p>利用字典序，使得<strong>string类型</strong>的a + b &lt; b + a</p><hr><h3 id="E61-扑克牌中的顺子"><a href="#E61-扑克牌中的顺子" class="headerlink" title="E61 扑克牌中的顺子"></a>E61 扑克牌中的顺子</h3><p><strong>排序</strong>：</p><p>less\<int\>()，从小到大排，是顺子需要两个条件，第一不能有重复的牌，第二max-min要小于等于4（会小于是因为可能比如12300的情况出现，即实际顺子的最大/最小可以由joker代替）</p><hr><h3 id="E40-最小的k个数"><a href="#E40-最小的k个数" class="headerlink" title="E40 最小的k个数"></a>E40 最小的k个数</h3><p>贴个链接：<a href="http://www.jiangluyu.xyz/2020/03/02/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/">排序算法详解</a></p><p>TOPK问题最快的方法是基于快速排序:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find_pivot</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        uniform_int_distribution&lt;<span class="keyword">unsigned</span>&gt; u(begin, end);</span><br><span class="line">        default_random_engine e;</span><br><span class="line">        <span class="keyword">return</span> u(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = find_pivot(arr, begin, end);</span><br><span class="line">        swap(arr[begin], arr[pivot]);</span><br><span class="line">        <span class="keyword">int</span> left = begin;</span><br><span class="line">        <span class="keyword">int</span> right = end;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= arr[begin]) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= arr[begin]) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                swap(arr[left], arr[right]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                swap(arr[left], arr[begin]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> pivot_index = partition(arr, begin, end);</span><br><span class="line">            <span class="keyword">if</span> (pivot_index == k) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pivot_index &gt; k) &#123;</span><br><span class="line">                quick_sort(arr, begin, pivot_index - <span class="number">1</span>, k);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                quick_sort(arr, pivot_index + <span class="number">1</span>, end, k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getLeastNumbers(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        quick_sort(arr, <span class="number">0</span>, arr.size() - <span class="number">1</span>, k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size(); i++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans = &#123;&amp;arr[<span class="number">0</span>], &amp;arr[<span class="number">0</span>] + k&#125;;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>区别在于，当下标为k时，无需再排序，而下标小于k时，只需要对右半部分排序，反之只需要对左半部分排序</p><hr><h3 id="H41-数据流中的中位数"><a href="#H41-数据流中的中位数" class="headerlink" title="H41 数据流中的中位数"></a>H41 数据流中的中位数</h3><p>这题是很少见的设计题，这里介绍一下堆这一数据结构。</p><blockquote><p>堆是一种基于「完全二叉树」的数据结构，可使用数组实现。以堆为原理的排序算法称为「堆排序」，基于堆实现的数据结构为「优先队列」。堆分为「大顶堆」和「小顶堆」，大（小）顶堆：任意节点的值不大于（小于）其父节点的值。</p></blockquote><p>最大堆，堆顶为最大元素；最小堆，堆顶为最小元素。</p><p>如下图所示，为包含 <code>1, 4, 2, 6, 8</code> 元素的小顶堆。将堆（完全二叉树）中的结点按层编号，即可映射到右边的数组存储形式。</p><div align="center"> <img src="https://pic.leetcode-cn.com/1599584901-xoiGEQ-Picture9.png"> </div><p>在C++中，priority_queue即优先队列，本质实现就是堆（默认为最大堆）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># priority_queue&lt;Type, Container, Functional&gt;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; minHeap;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; maxHeap;</span><br></pre></td></tr></table></figure><p>常用方法：</p><p>与队列queue一致。</p><p><strong>本题思路</strong>：</p><p>当两堆的数据个数相等时候，左边堆添加元素。</p><p>采用的方法不是直接将数据插入左边堆，而是将数据先插入右边堆，算法调整后</p><p>将堆顶的数据插入到左边堆，这样保证左边堆插入的元素始终是右边堆的最小值。</p><p>同理左边数据多，往右边堆添加数据的时候，先将数据放入左边堆，选出最大值放到右边堆中。</p><p>返回时，若两堆数量相等，则返回堆顶元素之和；否则返回最大堆堆顶。</p><p>注：返回double技巧（int*1.0)</p><hr><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="M14-2-剪绳子II"><a href="#M14-2-剪绳子II" class="headerlink" title="M14-2 剪绳子II"></a>M14-2 剪绳子II</h3><p><strong>数学证明</strong>：<a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/solution/mian-shi-ti-14-ii-jian-sheng-zi-iitan-xin-er-fen-f/410694">题解</a></p><p><strong>贪心思想</strong>：由数学证明可知&lt;=3时不用剪，&gt;4时当剪成3每段的时候最优</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">4</span>) &#123;</span><br><span class="line">        ans = ans * <span class="number">3</span> % p;</span><br><span class="line">        n -= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n * ans % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分类整理剑指Offer题目思路。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://www.jiangluyu.xyz/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://www.jiangluyu.xyz/tags/LeetCode/"/>
    
      <category term="C++" scheme="https://www.jiangluyu.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习笔记</title>
    <link href="https://www.jiangluyu.xyz/2020/03/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.jiangluyu.xyz/2020/03/20/Linux学习笔记/</id>
    <published>2020-03-20T12:28:07.000Z</published>
    <updated>2022-02-22T18:26:07.354Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>人生中第一次面试，体验难忘，收获也良多。其中一个收获便是学校要求与企业要求的巨大的不对称性，春招秋招是拉当前最符合企业要求的人上岸的。积累了第一次经验，下次努力。</p><p>参考课程（站点-组织-课程名-授课教师）：</p><ol><li>中国大学MOOC-北京邮电大学-Linux开发环境应用-蒋砚军/高占春/周安福</li><li>Coursera</li></ol></blockquote><a id="more"></a><h2 id="系统状态查看"><a href="#系统状态查看" class="headerlink" title="系统状态查看"></a>系统状态查看</h2><h3 id="Linux的字符终端"><a href="#Linux的字符终端" class="headerlink" title="Linux的字符终端"></a>Linux的字符终端</h3><ul><li><p>终端Terminal</p><ul><li><p>UNIX/Linux是<strong>多用户系统</strong></p><ul><li>主机连接多台字符终端</li><li>字符终端作为交互式输入输出设备</li></ul></li><li><p>终端构成</p><ul><li>键盘</li><li>显示器</li><li>RS232串行通信接口</li></ul></li><li>字符终端历史<ul><li>英文打字机（typewriter）</li><li>电传打字机（teletypewriter，简写tty）</li><li><strong>字符终端，以屏幕代替卷纸打印机（仍称作tty设备）</strong></li></ul></li></ul></li><li><p>主机与终端的链接</p><ul><li>串口卡引出多个RS232串口</li><li>每个RS232接口通过电缆（$\geq3%$芯）连接一台终端</li><li>RS232电缆早期长度限制10米，现在可达百米</li></ul></li><li><p>终端与主机的功能分工</p><ul><li><p>终端：主机的输入输出设备</p><ul><li>终端<strong>通过电缆将用户的按键信息送到主机，把主机发送过来的信息在屏幕上显示</strong></li></ul></li><li><p>主机：程序和数据的存储及处理</p><ul><li>数据及程序存放在主机的硬盘上，程序的运行也都由主机内的CPU占用主机内存来完成</li></ul><div align="center"><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200321162109.png"></div></li></ul></li><li><p>行律（line discipline）与驱动程序</p><ul><li><p>驱动程序</p><ul><li>驱动不同硬件</li><li>与行律模块的接口：上行和下行字符流</li></ul></li><li><p><strong>行律的作用</strong></p><ul><li><strong>一行内字符的缓冲、回显与编辑，直到按下回车</strong></li><li><strong>数据加工，如将\n转化为\r\n</strong></li><li><strong>将Ctrl+C字符转化为中止进程运行的信号（signal）</strong></li></ul></li></ul></li><li><p>主机与终端之间的通信过程</p><ul><li><p>运行程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Input N: "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"N * N = %d\n"</span>, n * n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Bye!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>终端按键五次</p><ul><li>1 7 Backspace 6 Enter</li></ul><div align="center"><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200321162116.png"></div></li></ul></li></ul><blockquote><p> Note: 回显退格的方式为，先用\b将光标往前移一格，再输入空格，再用\b将光标往前移一格。</p></blockquote><ul><li><p>行律功能的调整</p><ul><li><p>必要性：输入口令时不希望回显；不希望等到回车才将缓冲区内信息传递等</p></li><li><p>调整方法</p><ul><li><p>程序内编程</p></li><li><p>相关命令stty：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stty erase ^H <span class="comment"># ^H即对应ASCII码8，即Backspace，因为有的终端不支持Backspace按键</span></span><br><span class="line">stty -a <span class="comment"># 将行律中的所有信息状态打印出来</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>终端转义序列</p><ul><li><p>转义字符</p><ul><li><p>Esc：ASCII码<code>1B</code>（dec: 27, Oct: 033）</p><blockquote><p>Note：不支持输入时可以用\033</p></blockquote></li></ul></li><li>主机发往终端方向数据中的转义序列的功能<ul><li>控制光标位置、字符颜色、字符大小等</li><li>选择终端的字符集</li><li>控制终端上的打印机、刷卡器、磁条器、密码键盘</li></ul></li><li>举例<ul><li>Esc[2J 功能：清除屏幕</li><li>Esc[8A 功能：光标上移8行</li><li>Esc[16;8H 功能：光标上移16行8列</li><li>Esc[1;31m 功能：红色字符</li></ul></li></ul></li><li><p><strong>终端类型</strong></p><ul><li><strong>定义一组转义序列及其对应操作</strong></li><li>例如：ANSI，VT100，VT220等</li></ul></li><li><p>仿真终端和虚拟终端</p><ul><li><p>仿真终端</p><ul><li>PC机RS232串口，运行仿真软件模拟真正终端设备的功能，如CrossTalk，Win中的超级终端</li><li>仿真内容包括实现转义码序列功能</li></ul></li><li><p>虚拟终端</p><ul><li>终端与主机之间的通信由串口线变为TCP连接，双向传递字节流</li><li><strong>主机与PC通过网络相连，Client运行telnet，Server运行telnetd</strong></li><li><strong>安全终端，在TCP连接上加密和压缩数据，如SecureCRT与Putty</strong></li></ul><div align="center"><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200321162128.png"></div></li></ul></li></ul><h3 id="用户登录和联机手册的查阅"><a href="#用户登录和联机手册的查阅" class="headerlink" title="用户登录和联机手册的查阅"></a>用户登录和联机手册的查阅</h3><ul><li><p>普通用户和超级用户</p><ul><li><p>root用户</p><ul><li><strong>不受权限制约，可随意修改和删除文件</strong></li><li>误删文件可能带来严重后果</li></ul></li><li><p>创建新用户</p><p>由root用户创建（命令：<strong>useradd</strong>），用户信息存放在<strong>/etc/passwd</strong>文件中包括<strong>用户名</strong>和<strong>用户ID</strong>，以及<strong>Home目录</strong>，<strong>登录shell</strong>（一般为bash，也可以选其他shell，或应用程序）</p></li></ul></li><li><p>使用Linux</p><ul><li>登录成功后出现shell提示符<ul><li>$表示Bourne Shell系列</li><li><h1 id="表示当前用户为root"><a href="#表示当前用户为root" class="headerlink" title="表示当前用户为root"></a>表示当前用户为root</h1></li></ul></li><li><strong>对字母大小写敏感</strong></li></ul></li><li><p>基本Linux命令</p><ul><li><strong>man 查阅手册</strong></li><li><strong>date 日期与时间</strong></li><li><strong>cal 日历</strong></li><li><strong>bc 计算器</strong></li><li><strong>passwd 修改口令</strong></li></ul></li><li><p>man：查阅联机手册（manual前三个字母）</p><ul><li><p>手册内容</p><ul><li><strong>命令</strong>的说明书</li><li><strong>系统调用</strong>的使用手册</li><li>C语言和其他语言的<strong>库函数</strong>手册</li><li>系统<strong>配置文件格式</strong></li></ul></li><li><p>命令</p><ul><li>分页器：q-退出，space-下一页，上下箭头-上移下移</li></ul></li><li><p>用法</p><ul><li><p>man <em>name</em></p></li><li><p>man <em>section name</em></p><p>章节编号：<strong>1-命令，2-系统调用，3-库函数，5-配置文件</strong></p></li><li><p>man -k <em>regexp</em></p><p>列出<strong>关键字（keyword）</strong>与正则表达式regexp匹配的手册项目录</p></li></ul></li><li><p>内容</p><ul><li>基本功能和语法</li><li>对于C语言的函数调用，列出头文件及链接函数库</li><li>功能说明</li><li>SEE ALSO：有关的其他项目的名字和章节号</li></ul></li></ul></li></ul><h3 id="时间、计算器和口令维护"><a href="#时间、计算器和口令维护" class="headerlink" title="时间、计算器和口令维护"></a>时间、计算器和口令维护</h3><ul><li><p>date：读取系统日期和时间</p><ul><li><p>用法：</p><ul><li><p>date</p><p>读取系统日期和时间，如Wed Nov 7 21:09:16 CST 2018</p></li><li><p>根据需要定制输出格式</p><p>date “+%Y-%m-%d %H:%M:%S Day %j”</p><p>2018-11-07 21:09:54 Day 311</p><p>date “+%s”</p><p>1541596457</p><ul><li>311指今天是今年的第311天</li><li>格式控制：第一个字符必须为+号，%Y-年，%m-月，%d-日，%H-时，%M-分，%S-秒</li><li>%s-标坐标（从UTC1970开始），常用于计算时间间隔</li></ul></li><li><p>通过NTP协议（Network Time Protocol）校对系统时间：命令ntpdate</p><p>ntpdate 0.pool.ntp.org（设置时间，需要root用户）</p><p>ntpdate -q 0.pool.ntp.org（query，查询时间，普通用户即可）</p></li></ul></li></ul></li><li><p>cal：打印日历（calendar前三个字母）</p><ul><li>用法<ul><li>cal</li><li>cal <em>year</em></li><li>cal <em>month year</em></li></ul></li><li>举例<ul><li>cal 功能：打印当前月份的日历</li><li>cal 2020 功能：打印2020年的日历</li><li>cal 10 2019 功能：打印2019年10月份的日历</li><li>cal 12 功能：打印公元12年的日历</li></ul></li></ul></li><li><p>bc：计算器（basic calculator缩写）</p><ul><li><p>功能强大</p><ul><li>基本计算器功能</li><li>支持变量a~z，函数，条件，循环等编程功能</li><li>进行任意精度的计算</li></ul></li><li><p>精度</p><ul><li><p>缺省精度</p><ul><li><strong>bc 缺省精度为1</strong></li><li>bc -l缺省精度为小数点后20位</li></ul></li><li><p>通过scale自行决定精度</p><ul><li><p>scale=10000</p><p>s(1.0) 即求小数点后10000位精度的sin(1.0)的值</p></li></ul></li></ul></li></ul></li><li><p>passwd：更换口令（password缩写）</p><ul><li><p>普通用户</p><ul><li><strong>使用passwd命令修改自己的口令，须先验证原口令</strong></li></ul></li><li><p>root</p><ul><li><p>直接修改新口令</p></li><li><p><strong>可强制修改其他用户口令，但无法读取其他用户口令</strong></p></li><li><p>例如：passwd liu</p><p>将liu的口令强制设置为新口令</p></li></ul></li></ul></li><li><p>口令的设置与验证</p><ul><li>口令的保存：不存明码</li></ul><div align="center"><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200321162154.png"></div><ul><li>验证方法：验证生成序列+输入的口令通过哈希算法后是否与存储的哈希值相同</li></ul></li></ul><h3 id="了解系统状态"><a href="#了解系统状态" class="headerlink" title="了解系统状态"></a>了解系统状态</h3><ul><li><p>几个了解系统状态的命令</p><ul><li>who：确定谁在系统中</li><li>uptime：了解系统启动时间及忙碌程度</li><li>top：列出资源占用排名靠前的进程</li><li>free：了解内存使用情况</li><li>vmstat：了解系统负载情况</li></ul></li><li><p>who：确定谁在系统中</p><ul><li><p>who：列出当前登入系统的用户</p><p>| 用户名 | 终端设备的设备文件名 | 登录时间    |<br>| ——— | —————————— | —————- |<br>| wujian | tty00                | Jul 5 14:49 |<br>| sun    | tty01                | Jul 5 11:31 |</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200321162159.png" alt="image-20200320221411992"></p><p>设备文件一般存放于/dev下</p></li><li><p>tty：打印当前终端的设备文件名</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200321162203.png" alt="image-20200320221436881"></p></li><li><p>who am i：列出当前终端上的登录用户信息</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200321162309.png" alt="image-20200320221514313"></p></li><li><p>whoami：仅列出当前终端上的登录用户名</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200321162312.png" alt="image-20200320221451656"></p></li></ul></li><li><p>uptime：已开机时间</p><ul><li><p>uptime：系统运行时间，当前登入用户数，近期（1min，5min，15min）内CPU负载（平均调度队列长度）</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200321162317.png" alt="image-20200320221349193"></p></li></ul></li><li><p>top：列出资源占用排名靠前的进程</p><ul><li><p>top</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200321162320.png" alt="image-20200320221621163"></p><ul><li><p>第一行，任务队列信息，同uptime命令的执行结果</p></li><li><p>第二行，Tasks进程</p></li><li><p>第三行，CPU状态信息</p><p>us（user space）- 用户空间占用CPU的百分比。</p><p>sy（sysctl）-内核空间占用CPU的百分比。</p><p>ni-改变过优先级的进程占用CPU的百分比</p><p>id（idolt）-空闲CPU百分比</p><p>wa（wait）-IO等待占用CPU的百分比</p><p>hi（Hardware Interrupts）-硬中断占用CPU的百分比</p><p>si（Software Interrupts）-软中断占用CPU的百分比</p></li><li><p>第四行，内存状态</p></li><li><p>第五行，swap交换分区信息</p></li><li><p>第七行以下：各进程的状态监控</p><p>PID-进程id</p><p>USER-用户</p><p>PR（priority）-进程优先级</p><p>NI（nice）-负-&gt;正，高优先级-&gt;低优先级</p><p>VIRT（virtual）-进程逻辑地址空间大小</p><p>RES（Resident）-驻留内存数即占用物理内存数</p><p>SHR（share）-与其他进程共享内存数</p><p>%CPU-占用CPU百分比</p><p>%MEM-占用内存百分比</p><p>TIME+-占用的CPU时间</p><p>COMMAND-进程名称（命令名/命令行）</p></li></ul></li></ul></li><li><p>ps（process status）：查询进程状态</p><ul><li><p>选项</p><ul><li><p>空：只列出在当前终端上启动的进程（PID，TTY，TIME，COMMAND）</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200321162325.png" alt="image-20200321021001829"></p></li><li><p>-e：列出系统中所有进程</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200321162327.png" alt="image-20200321021027911"></p></li><li><p>-f：以full格式列出每一个进程</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200321162330.png" alt="image-20200321021047262"></p></li><li><p>-l：以long格式列出每一个进程</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200321162333.png" alt="image-20200321021058686"></p></li></ul></li><li>进程属性<ul><li>UID（user id）</li><li>PID（process id）</li><li>PPID（parent process id）</li><li>C（CPU）：最近一段时间（秒级别）CPU占用情况</li><li>STIME：启动时间</li><li>SZ：进程逻辑内存大小</li><li>TTY</li><li>COMMAND</li><li>WCHAN（wait channel）：进程在内核的何处睡眠</li><li>TIME：累计执行时间（占用CPU的时间）</li><li>PRI（priority）</li><li>S（status）：Sleep，Run，Zombie（结束后暂时还未关闭）</li></ul></li></ul></li><li><p>free：了解内存使用情况</p><ul><li><p>free</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200321162337.png" alt="image-20200321020203874"></p><p>内存总量1.8GB，空闲69MB</p><p>Linux为提高效率，利用程序暂时不用的内存，缓冲读写过的磁盘信息，减少I/O时间，当前有313MB的buffer/cache</p><p>不计buffer/cache，系统有实际可利用资源179MB</p><p>打印了磁盘Swap区的使用情况</p></li></ul></li><li><p>vmstat：了解系统负载</p><ul><li><p>vmstat</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200321162340.png" alt="image-20200321020608078"></p><ul><li>procs：r-待运行的进程数，b-处在非中断睡眠状态的进程数</li><li>memory：空闲的内存，buffer/cache用做缓存的内存数</li><li>swap：磁盘/内存的交换页数量（单位：KB/s）</li><li>IO：块设备的I/O块数（单位：块/s）</li><li>system：in（interrupt）-每秒的硬件中断数，包括时钟中断，cs（context switch）-每秒的环境切换次数</li><li>CPU：CPU的总使用率，us（user），sy（system），id（idle），wa（wait for disk I/O）</li></ul></li></ul></li></ul><h3 id="复习题"><a href="#复习题" class="headerlink" title="复习题"></a>复习题</h3><ol><li><p>C语言编写的应用程序，通过printf打印一个换行符\n，但在终端上执行的是回车加换行\r\n，把换行符替换为回车换行是由下面哪个软件模块完成的？</p><p><code>Linux内核中的行律模块</code></p></li><li><p>Linux超级用户的用户名为：</p><p><code>root</code></p></li><li><p>哪个命令可以获得某进程占用的逻辑内存大小？</p><p><code>top</code></p></li><li><p>哪个命令可以了解目前系统CPU的空闲情况？</p><p><code>uptime</code></p></li><li><p>传统的终端与Linux主机之间传输的是字节流。（true or false)</p><p><code>true</code></p></li><li><p>终端转义序列的意义在于终端收到某一特定字符序列后执行一些约定好的控制功能，而不是把这些字符显示在显示器上。（true or false)</p><p><code>true</code></p></li><li><p>在终端按下Ctrl-C按键一般会导致一个死循环程序中止运行，这是因为按下Ctrl-C之后终端并不向Linux输送字符，而是通过RS232接口的一条特殊信号线通知Linux主机，将进程终止。（true or false)</p><p><code>false（通过行律）</code></p></li><li><p>Linux命令不区分字母的大小写，一般习惯用小写字母。（true or false)</p><p><code>false（Linux区分大小写）</code></p></li><li><p>直接执行bc命令，后面不带任何选项，除法计算时保留小数点后20个有效数字。（true or false)</p><p><code>false（默认精度为1）</code></p></li><li><p>Linux中超级用户的权限很大，可以读取普通用户的口令值。（true or false)</p><p><code>false（只能强制修改，不能读取）</code></p></li></ol><h2 id="文本文件的处理"><a href="#文本文件的处理" class="headerlink" title="文本文件的处理"></a>文本文件的处理</h2><h3 id="文本文件及处理工具"><a href="#文本文件及处理工具" class="headerlink" title="文本文件及处理工具"></a>文本文件及处理工具</h3><ul><li><p>Linux中的文本信息</p><ul><li>文本文件<ul><li>C语言、Java语言等的编程文件</li><li>文本格式的数据文件</li><li>文本格式的文字信息</li></ul></li><li>程序输出</li><li>系统配置信息<ul><li>/etc下的配置文件（类似win下的注册表）</li></ul></li><li>文本型网络协议<ul><li>大部分传输层以上协议</li><li>会话层协议：HTTP，POP3，SMTP，IMAP</li><li>表示层协议：HTML，XML，MIME</li></ul></li><li>文本文件处理的命令<ul><li>Linux提供大量 的文本文件处理的命令</li><li>命令自带的选项</li></ul></li></ul></li><li><p>进程的标准输入/输出</p><ul><li><p>进程的基本概念</p><ul><li><p>进程和程序</p><p>程序：存储在计算机上的代码文件</p><p>进程：经过编译后正在运行的程序</p></li></ul></li><li><p>进程的输入输出</p><ul><li>stdin，默认键盘</li><li>stdout，默认屏幕</li></ul></li></ul></li><li><p>重定向与管道</p><ul><li><p>重定向机制</p><ul><li><p>输出重定向</p><p>如：ls -l  &gt; filelist.txt</p><blockquote><p>Note：本身ls -l会将信息显示在屏幕上，上述命令将其写入filelist.txt文件中，不会再打印在屏幕上</p></blockquote></li><li><p>输入重定向</p><p>如：sort &lt; filelist.txt</p><blockquote><p>Note：sort默认从stdin中获取输入，上述命令使sort从filelist.txt中获取输入</p></blockquote></li><li><p>重定向机制与管道机制的重要性</p></li></ul></li></ul></li><li><p>文本文件处理命令的特点</p><ul><li><p>特点</p><ul><li>不指定对象时，默认从stdin获得数据</li><li>制定对象时，从对象中获得数据</li><li>多数命令可以指定多个文件</li><li>处理结果将在stdout显示</li></ul></li><li><p>考虑的因素</p><ul><li>标准输入/标准输出</li><li>shell的文件通配符（可以同时处理多个对象）</li><li>输入输出重定向</li><li>管道</li></ul></li><li><p>灵活性：工具命令的组合</p><ul><li><p>Linux倾向于提供独立的多个精巧的工具命令，数据格式为文本信息</p></li><li><p>鼓励使用重定向或管道机制将多个工具命令组合，提供更灵活的功能</p></li><li><p>应用系统设计时，也应该考虑到这些特点</p><p>如数据库显示，直接输出多列文本，考虑到各种工具软件的使用</p></li></ul></li></ul></li></ul><h3 id="读取文件内容"><a href="#读取文件内容" class="headerlink" title="读取文件内容"></a>读取文件内容</h3><ul><li><p>文本文件读取与处理的几个命令</p><ul><li>more/less：逐屏显示文件</li><li>cat（concatenate）/od（octal dump）：列出文件内容</li><li>head/tail：列出文件的头部/尾部</li><li>tee：三通</li><li>wc（word count）：字计数</li><li>sort：对文件内容排序</li><li>tr（translate）：翻译字符</li><li>uniq（unique）：筛选重复行</li></ul></li><li><p>more/less：逐屏显示文件</p><ul><li>历史<ul><li>more：BSD UNIX开发</li><li>less：Linux广泛使用</li></ul></li><li>使用方法：<ul><li>more shudu.c 指定单个文件</li><li>more *.[ch] 指定多个文件</li><li>ls -l| more 指定0个文件（因为从管道中获取输入）</li><li>less shudu.c</li></ul></li></ul></li><li><p>more</p><ul><li><p>more</p><p>满屏后，显示—more—或—more—(15%)，more命令</p><ul><li>空格：显示下一屏</li><li>回车：下移一行</li><li>q（quit）</li><li>/<em>pattern</em>：搜索指定pattern的字符串，正则表达式</li><li>/：继续查找指定模式的字符串</li><li>h（help）</li><li>^L：屏幕刷新</li></ul></li></ul></li><li><p>less</p><ul><li>less：来源为less is more<ul><li>回退浏览功能更强：上下箭头键、J、K、PgUp等键</li><li>有些Unix系统不提供less命令</li></ul></li></ul></li><li><p>cat/od：列出文件内容</p><ul><li><p>命名与功能</p><ul><li>cat：concatenate：串结，文本格式打印（-n：显示行号）</li><li>od：octal dump：逐字节打印（-c，-t c，-t x1，-t d1，-t u1）</li></ul></li><li><p>举例</p><ul><li><p>cat tryl.c</p></li><li><p>cat -n shudu.c</p></li><li><p>cat tryl.c tryx.c try.h</p></li><li><p>cat &gt; try 命令行参数为0个，直接从stdin获取数据，知道^D，将内容写入try文件中</p></li><li><p>cat tryl.c try2.c try.h &gt; trysrc</p></li><li><p>cat makefile *.[ch] &gt; src</p></li><li><p>od -t x1 x.dat 以十六进制打印文件x.dat的各字节</p></li><li><p>od -t x1 x.dat | more</p></li><li><p>od -c /bin/bash <strong>逐字符</strong>打印文件，遇到不可打印字符则打印编码</p></li><li><p>echo abcdABCD | od -t x1 十六进制显示abcdABCD的ASCII码</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200321162346.png" alt="image-20200321161435322"></p></li></ul></li></ul></li><li><p>head/tail：显示文件的头部和尾部</p><p>默认10行，-n可以指定行数</p><ul><li><p>head -n 15 ab.c</p></li><li><p>head -n 23 a.c b.c c.c | more</p></li><li><p>tail -n 40 a.txt</p></li><li><p>head -n -20 msg.c 除去尾部20行，其余均显示</p></li><li><p>tail -n +20 msg.c 除去开头20行，其余均显示</p></li><li><p><strong>tail -f debug.txt 实时打印文件尾部被追加的内容</strong></p><blockquote><p>组合运用如：netstat -s -p tcp | head, ls -s | sort | head -n 20</p></blockquote></li></ul></li></ul><h3 id="文本数据的处理"><a href="#文本数据的处理" class="headerlink" title="文本数据的处理"></a>文本数据的处理</h3><ul><li><p>tee：三通</p><ul><li><p>功能</p><p>将stdin得到的数据抄送stdout，同时存入文件</p></li><li><p>举例</p><p>./myap | tee myap.log</p></li></ul></li><li><p>wc(word count)：字计数</p><ul><li><p>功能</p><ul><li>列出文件的行数，单词数，字符数</li><li>当文件数$\gt1$时，最后还列出一个合计</li><li>常用选项-l，只列出行数</li></ul></li><li><p>举例</p><ul><li><p>wc sum.c</p></li><li><p>wc x.c makefile start.sh</p></li><li><p>wc -l *.c makefile start.sh</p></li><li><p>ps -ef | wc -l</p></li><li><p>ps -ef | grep liang | wc -l</p><blockquote><p>Note：grep为正则表达式或查找字符串，上述命令即在所有full格式的进程信息中查找包含liang字符串的进程数（即行数）</p></blockquote></li><li><p>who | wc -l</p></li></ul></li></ul></li><li><p>sort：对文件内容排序</p><ul><li><p>sort选项</p><ul><li><p>-n（numeric）：对于数字按照算术值大小排序，而非字符串比较规则排序</p><blockquote><p>Note：字符串规则排序时，67$\gt$123</p></blockquote></li><li><p>可以选择行中某一部分作为排序关键字</p></li><li>选择升序或降序</li><li>字符串比较时对字母是否区分大小写</li><li>内排序，外排序等算法的选择</li></ul></li><li><p>举例</p><ul><li><p>sort telno &gt; telno1</p></li><li><p>ls -s | sort | tail -n 10</p></li><li><p>ls -s | sort -n | tail -10</p><blockquote><p>Note：tail -10与tail -n 10等价，即显示倒数10行</p></blockquote></li></ul></li></ul></li><li><p>tr（translate）：翻译字符</p><ul><li><p>用法</p><p>tr <em>string1</em> <em>string2</em></p><p>把stdin拷贝到stdout，字符串1中出现的字符替换为字符串2中的对应字符</p></li><li><p>举例</p><ul><li><p>cat linuxlearn.txt | tr u U</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200321165219.png" alt="image-20200321165209727"></p></li><li><p>cat linuxlearn.txt | tr ‘[a-z]’ ‘[A-Z]’</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200321165330.png" alt="image-20200321165253259"></p></li><li><p>cat file1 | tr ‘\012’ % 将换行符换为%</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200321165437.png" alt="image-20200321165434265"></p></li></ul></li></ul></li><li><p>uniq（unique）：筛选文件中的重复行</p><ul><li><p>用法</p><ul><li>uniq <em>options</em></li><li>uniq <em>options inputfile</em></li><li>uniq <em>options inputfile outputfile</em></li></ul></li><li><p>重复的行</p><p><strong>重复的行定义为紧邻两行的内容相同</strong></p></li><li><p>选项</p><ul><li>空：打印没有重复的行与有重复的行（但仅打印一次）</li><li>-u（unique）：只保留没有重复的行</li><li>-d（duplicated）：只保留有重复的行，但仅打印一次</li><li>-c（count）：计数同样的行出现几次</li></ul></li></ul></li></ul><h3 id="复习题-1"><a href="#复习题-1" class="headerlink" title="复习题"></a>复习题</h3><ol><li><p>使用less命令逐屏显示文本文件时，使得显示内容上滚一行而不是滚动一屏，应按下哪个键？</p><p><code>回车/↓</code></p></li><li><p>Linux中用来实现计数功能，比如：统计系统有多少个登录用户，实现计数功能的命令是：</p><p><code>wc -l</code></p></li><li><p>Linux使用|符号连接两个命令使用管道机制，设计管道机制的目的是：</p><p><code>将前一个命令的输出作为下个命令的输入，提供更灵活的功能</code></p></li><li><p>uniq命令可以通过它的选项，选择打印所有只出现一次的行，或者打印出现不只一次的行，或者两种都选。但无论哪种情况，重复出现的行最多只能打印一次。（true or false）</p><p><code>true</code></p></li><li><p>一个应用程序的C语言源程序通过printf语句在标准输出输出信息，运行时只要使用输出重定向机制，不需要修改原先的程序加入文件操作的代码，就可以把输出结果存入指定名字的文件。（true or false）</p><p><code>true</code></p></li><li><p>less命令时more命令的一个简化版本，精简后功能比more弱，但更节约内存和CPU。（true or false）</p><p><code>false（less和more是两种实现不同的命令）</code></p></li><li><p>tail命令的-f选项可以让tail命令持续运行下去，持续地将它操作的文本文件新增的数据显示出来。如果这个文本文件被其他进程随时间推移断断续续追加几行，tail也会断断续续地输出这些新增的内容。（true or false）</p><p><code>true</code></p></li><li><p>可以为tee命令提供一个文件名abc.log，例如：xyz | tee abc.log 那么，通过管道的方式可以把前面xyz命令的输出结果在当前终端上显示的同时也存入磁盘文件abc.log，可供事后查阅。如果以某用户正在使用的终端的设备文件名(如/dev/pts/2)代替文件名abc.log，那么，这个xyz命令执行时的输出就会同时在两个终端上实时显示。就算是把前面的xyz命令换成vi也是完全可能的，也就是说完全可能在第二个终端上实时看到第一个终端上的编辑画面。（true or false）</p><p><code>true</code></p></li><li><p>不带任何选项的uniq命令消除数据中重复的行。一旦某一行出现过，uniq会记录下来，以后无论这一行在以后什么地方再次出现，输出时都会被忽略，保证数据的唯一行。（true or false）</p><p><code>false（重复的行的定义仅为相邻的两行是否相同）</code></p></li><li><p>信息由一个个字节组成，tr命令处理这些信息时，可以将256种字节值中的任何一种取值“翻译”为另一个字节值，并且不限于可打印字符之间的转译，比如把换行符替换为斜线。（true or false）</p><p><code>true</code></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;人生中第一次面试，体验难忘，收获也良多。其中一个收获便是学校要求与企业要求的巨大的不对称性，春招秋招是拉当前最符合企业要求的人上岸的。积累了第一次经验，下次努力。&lt;/p&gt;
&lt;p&gt;参考课程（站点-组织-课程名-授课教师）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;中国大学MOOC-北京邮电大学-Linux开发环境应用-蒋砚军/高占春/周安福&lt;/li&gt;
&lt;li&gt;Coursera&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://www.jiangluyu.xyz/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.jiangluyu.xyz/tags/Linux/"/>
    
      <category term="初学者" scheme="https://www.jiangluyu.xyz/tags/%E5%88%9D%E5%AD%A6%E8%80%85/"/>
    
  </entry>
  
  <entry>
    <title>六道股票问题</title>
    <link href="https://www.jiangluyu.xyz/2020/03/09/%E5%85%AD%E9%81%93%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"/>
    <id>https://www.jiangluyu.xyz/2020/03/09/六道股票问题/</id>
    <published>2020-03-09T03:33:29.000Z</published>
    <updated>2021-08-16T18:16:27.721Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章为转载，侵删，仅供自己收藏</p><p>[英文版][<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems</a>]<br>[中文版翻译][<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/</a>]</p></blockquote><a id="more"></a><h3 id="0-背景"><a href="#0-背景" class="headerlink" title="0 背景"></a>0 背景</h3><p>很多读者抱怨股票系列问题奇技淫巧太多，如果面试真的遇到这类问题，基本不会想到那些巧妙的办法，怎么办？所以本文拒绝奇技淫巧，而是稳扎稳打，只用一种通用方法解决所用问题，以不变应万变。</p><p>这篇文章用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 DP table，看一眼就明白了。</p><p>先随便抽出一道题，看看别人的解法：      </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> s1 = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> s2 = INT_MIN;</span><br><span class="line">    <span class="keyword">int</span> s3 = INT_MIN;</span><br><span class="line">    <span class="keyword">int</span> s4 = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i) &#123;            </span><br><span class="line">        s1 = max(s1, -prices[i]);</span><br><span class="line">        s2 = max(s2, s1 + prices[i]);</span><br><span class="line">        s3 = max(s3, s2 - prices[i]);</span><br><span class="line">        s4 = max(s4, s3 + prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> max(<span class="number">0</span>, s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能看懂吧？会做了吗？不可能的，你看不懂，这才正常。就算你勉强看懂了，下一个问题你还是做不出来。为什么别人能写出这么诡异却又高效的解法呢？因为这类问题是有框架的，但是人家不会告诉你的，因为一旦告诉你，你五分钟就学会了，该算法题就不再神秘，变得不堪一击了。</p><p>本文就来告诉你这个框架，然后带着你一道一道秒杀。</p><p>这 6 道股票买卖问题是有共性的，我们通过对第四题（限制最大交易次数为 k）的分析一道一道解决。因为第四题是一个最泛化的形式，其他的问题都是这个形式的简化。</p><p>第一题是只进行一次交易，相当于 k = 1；第二题是不限交易次数，相当于 k = +infinity（正无穷）；第三题是只进行 2 次交易，相当于 k = 2；剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种，都很容易处理。</p><h3 id="1-穷举框架"><a href="#1-穷举框架" class="headerlink" title="1 穷举框架"></a>1 穷举框架</h3><p>首先，还是一样的思路：如何穷举？这里的穷举思路和上篇文章递归的思想不太一样。</p><p>递归其实是符合我们思考的逻辑的，一步步推进，遇到无法解决的就丢给递归，一不小心就做出来了，可读性还很好。缺点就是一旦出错，你也不容易找到错误出现的原因。比如上篇文章的递归解法，肯定还有计算冗余，但确实不容易找到。</p><p>而这里，我们不用递归思想进行穷举，而是利用「状态」进行穷举。我们具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。听起来抽象，你只要记住「状态」和「选择」两个词就行，下面实操一下就很容易明白了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> in 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> in 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 择优(选择<span class="number">1</span>，选择<span class="number">2</span>...)</span><br></pre></td></tr></table></figure><p>比如说这个问题，每天都有三种「选择」：<strong>买入、卖出、无操作</strong>，我们用 <strong>buy, sell, rest</strong> 表示这三种选择。但问题是，并不是每天都可以任意选择这三种选择的，因为 <strong>sell 必须在 buy 之后，buy 必须在 sell 之后</strong>。那么 rest 操作还应该分两种状态，<strong>一种是 buy 之后的 rest（持有了股票），一种是 sell 之后的 rest（没有持有股票）</strong>。而且别忘了，我们还有交易次数 k 的限制，就是说你 buy 还只能在 k &gt; 0 的前提下操作。</p><p>很复杂对吧，不要怕，我们现在的目的只是穷举，你有再多的状态，老夫要做的就是一把梭全部列举出来。这个问题的「状态」有三个，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k][<span class="number">0</span> or <span class="number">1</span>]</span><br><span class="line"><span class="number">0</span> &lt;= i &lt;= n-<span class="number">1</span>, <span class="number">1</span> &lt;= k &lt;= K</span><br><span class="line">n 为天数，大 K 为最多交易数</span><br><span class="line">此问题共 n × K × <span class="number">2</span> 种状态，全部穷举就能搞定。</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt;= i &lt; n:</span><br><span class="line">    <span class="keyword">for</span> <span class="number">1</span> &lt;= k &lt;= K:</span><br><span class="line">        <span class="keyword">for</span> s in &#123;<span class="number">0</span>, <span class="number">1</span>&#125;:</span><br><span class="line">            dp[i][k][s] = max(buy, sell, rest)</span><br></pre></td></tr></table></figure><p>而且我们可以用自然语言描述出每一个状态的含义，比如说<code>dp[3][2][1]</code>的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如<code>dp[2][3][0]</code>的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。很容易理解，对吧？</p><p>我们想求的最终答案是<code>dp[n - 1][K][0]</code>即最后一天，最多允许 K 次交易，最多获得多少利润。读者可能问为什么不是<code>dp[n - 1][K][1]</code>？因为<code>[1]</code>代表手上还持有股票，<code>[0]</code> 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。</p><p>记住如何解释「状态」，一旦你觉得哪里不好理解，把它翻译成自然语言就容易理解了。</p><h3 id="2-状态转移框架"><a href="#2-状态转移框架" class="headerlink" title="2 状态转移框架"></a>2 状态转移框架</h3><p>现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。只看「持有状态」，可以画个状态转移图。</p><p>通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程：</p><p>dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])<br>              max(   选择 rest  ,           选择 sell      )</p><p>解释：今天我没有持有股票，有两种可能：<br>要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；<br>要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">              max(选择rest      ，选择buy)</span><br></pre></td></tr></table></figure><p>解释：今天我持有着股票，有两种可能：<br><strong>要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；</strong><br><strong>要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。</strong></p><p>这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的。</p><p>现在，我们已经完成了动态规划中最困难的一步：状态转移方程。如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了。不过还差最后一点点，就是定义 base case，即最简单的情况。</p><p><code>dp[-1][k][0] = 0</code><br>解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。<br><code>dp[-1][k][1] = -infinity</code><br>解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。<br><code>dp[i][0][0] = 0</code><br>解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。<br><code>dp[i][0][1] = -infinity</code><br>解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。<br>把上面的状态转移方程总结一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">base <span class="keyword">case</span>：</span><br><span class="line">dp[-<span class="number">1</span>][k][<span class="number">0</span>] = dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">dp[-<span class="number">1</span>][k][<span class="number">1</span>] = dp[i][<span class="number">0</span>][<span class="number">1</span>] = -infinity</span><br><span class="line"></span><br><span class="line">状态转移方程：</span><br><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><p>读者可能会问，这个数组索引是 -1 怎么编程表示出来呢，负无穷怎么表示呢？这都是细节问题，有很多方法实现。现在完整的框架已经完成，下面开始具体化。</p><h3 id="3-秒杀题目"><a href="#3-秒杀题目" class="headerlink" title="3 秒杀题目"></a>3 秒杀题目</h3><h4 id="3-1-k-1"><a href="#3-1-k-1" class="headerlink" title="3.1 k = 1"></a>3.1 k = 1</h4><p>直接套状态转移方程，根据 base case，可以做一些化简：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">1</span>][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] - prices[i]) </span><br><span class="line">            = max(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], -prices[i])</span><br></pre></td></tr></table></figure><p>解释：k = 0 的 base case，所以<code>dp[i-1][0][0] = 0</code>。</p><p>现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。<br>可以进行进一步化简去掉所有 k：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][<span class="number">1</span>], -prices[i])</span><br></pre></td></tr></table></figure><p>直接写出代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = prices.length;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">    dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>显然 i = 0 时<code>dp[i-1]</code>是不合法的。这是因为我们没有对 i 的 base case 进行处理。可以这样处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i - <span class="number">1</span> == -<span class="number">1</span>) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 解释：</span></span><br><span class="line">        <span class="comment">//   dp[i][0] </span></span><br><span class="line">        <span class="comment">// = max(dp[-1][0], dp[-1][1] + prices[i])</span></span><br><span class="line">        <span class="comment">// = max(0, -infinity + prices[i]) = 0</span></span><br><span class="line">        dp[i][<span class="number">1</span>] = -prices[i];</span><br><span class="line">        <span class="comment">//解释：</span></span><br><span class="line">        <span class="comment">//   dp[i][1] </span></span><br><span class="line">        <span class="comment">// = max(dp[-1][1], dp[-1][0] - prices[i])</span></span><br><span class="line">        <span class="comment">// = max(-infinity, 0 - prices[i]) </span></span><br><span class="line">        <span class="comment">// = -prices[i]</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">    dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n-<span class="number">1</span>][<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>第一题就解决了，但是这样处理 base case 很麻烦，而且注意一下状态转移方程，新状态只和相邻的一个状态有关，其实不用整个 dp 数组，只需要一个变量储存相邻的那个状态就足够了，这样可以把空间复杂度降到 O(1):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k == 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_k_1</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="comment">// base case: dp[-1][0] = 0, dp[-1][1] = -infinity</span></span><br><span class="line">    <span class="keyword">int</span> dp_i_0 = <span class="number">0</span>, dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span></span><br><span class="line">        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">        <span class="comment">// dp[i][1] = max(dp[i-1][1], -prices[i])</span></span><br><span class="line">        dp_i_1 = Math.max(dp_i_1, -prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种方式都是一样的，不过这种编程方法简洁很多。但是如果没有前面状态转移方程的引导，是肯定看不懂的。后续的题目，我主要写这种空间复杂度 O(1) 的解法。</p><h4 id="3-2-k-infinity"><a href="#3-2-k-infinity" class="headerlink" title="3.2 k = +infinity"></a>3.2 k = +infinity</h4><p>如果 k 为正无穷，那么就可以认为 k 和 k - 1 是一样的。可以这样改写框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">            = max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><p>我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><p>直接翻译成代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_k_inf</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">int</span> dp_i_0 = <span class="number">0</span>, dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = dp_i_0;</span><br><span class="line">        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">        dp_i_1 = Math.max(dp_i_1, temp - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-k-infinity-with-cooldown"><a href="#3-3-k-infinity-with-cooldown" class="headerlink" title="3.3 k = +infinity with cooldown"></a>3.3 k = +infinity with cooldown</h4><p>每次 sell 之后要等一天才能继续交易。只要把这个特点融入上一题的状态转移方程即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">2</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><p>解释：第 i 天选择 buy 的时候，要从 i-2 的状态转移，而不是 i-1 。<br>翻译成代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_with_cool</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">int</span> dp_i_0 = <span class="number">0</span>, dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> dp_pre_0 = <span class="number">0</span>; <span class="comment">// 代表 dp[i-2][0]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = dp_i_0;</span><br><span class="line">        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">        dp_i_1 = Math.max(dp_i_1, dp_pre_0 - prices[i]);</span><br><span class="line">        dp_pre_0 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-k-infinity-with-fee"><a href="#3-4-k-infinity-with-fee" class="headerlink" title="3.4 k = +infinity with fee"></a>3.4 k = +infinity with fee</h4><p>每次交易要支付手续费，只要把手续费从利润中减去即可。改写方程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i] - fee)</span><br></pre></td></tr></table></figure><p>解释：相当于买入股票的价格升高了。<br>在第一个式子里减也是一样的，相当于卖出股票的价格减小了。<br>直接翻译成代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_with_fee</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">int</span> dp_i_0 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = dp_i_0;</span><br><span class="line">        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">        dp_i_1 = Math.max(dp_i_1, temp - prices[i] - fee);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5-k-2"><a href="#3-5-k-2" class="headerlink" title="3.5 k = 2"></a>3.5 k = 2</h4><p>k = 2 和前面题目的情况稍微不同，因为上面的情况都和 k 的关系不太大。要么 k 是正无穷，状态转移和 k 没关系了；要么 k = 1，跟 k = 0 这个 base case 挨得近，最后也没有存在感。</p><p>这道题 k = 2 和后面要讲的 k 是任意正整数的情况中，对 k 的处理就凸显出来了。我们直接写代码，边写边分析原因。</p><p>原始的动态转移方程，没有可化简的地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><p>按照之前的代码，我们可能想当然这样写代码（错误的）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> k = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][k + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">if</span> (i - <span class="number">1</span> == -<span class="number">1</span>) &#123; <span class="comment">/* 处理一下 base case*/</span> &#125;</span><br><span class="line">    dp[i][k][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line">    dp[i][k][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n - <span class="number">1</span>][k][<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>为什么错误？我这不是照着状态转移方程写的吗？</p><p>还记得前面总结的「穷举框架」吗？就是说我们必须穷举所有状态。其实我们之前的解法，都在穷举所有状态，只是之前的题目中 k 都被化简掉了。这道题由于没有消掉 k 的影响，所以必须要对 k 进行穷举：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max_k = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][max_k + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = max_k; k &gt;= <span class="number">1</span>; k--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i - <span class="number">1</span> == -<span class="number">1</span>) &#123; <span class="comment">/*处理 base case */</span> &#125;</span><br><span class="line">        dp[i][k][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line">        dp[i][k][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 穷举了 n × max_k × 2 个状态，正确。</span></span><br><span class="line"><span class="keyword">return</span> dp[n - <span class="number">1</span>][max_k][<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>如果你不理解，可以返回第一点「穷举框架」重新阅读体会一下。</p><p>这里 k 取值范围比较小，所以可以不用 for 循环，直接把 k = 1 和 2 的情况手动列举出来也可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">2</span>][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">2</span>][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], -prices[i])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_k_2</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp_i10 = <span class="number">0</span>, dp_i11 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> dp_i20 = <span class="number">0</span>, dp_i21 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">        dp_i20 = Math.max(dp_i20, dp_i21 + price);</span><br><span class="line">        dp_i21 = Math.max(dp_i21, dp_i10 - price);</span><br><span class="line">        dp_i10 = Math.max(dp_i10, dp_i11 + price);</span><br><span class="line">        dp_i11 = Math.max(dp_i11, -price);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有状态转移方程和含义明确的变量名指导，相信你很容易看懂。其实我们可以故弄玄虚，把上述四个变量换成 a, b, c, d。这样当别人看到你的代码时就会一头雾水，大惊失色，不得不对你肃然起敬。</p><h4 id="3-6-k-any-integer"><a href="#3-6-k-any-integer" class="headerlink" title="3.6 k = any integer"></a>3.6 k = any integer</h4><p>有了上一题 k = 2 的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的 k 值会非常大，dp 数组太大了。现在想想，交易次数 k 最多有多大呢？</p><p>一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 k 应该不超过 n/2，如果超过，就没有约束作用了，相当于 k = +infinity。这种情况是之前解决过的。</p><p>直接把之前的代码重用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_k_any</span><span class="params">(<span class="keyword">int</span> max_k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">if</span> (max_k &gt; n / <span class="number">2</span>) </span><br><span class="line">        <span class="keyword">return</span> maxProfit_k_inf(prices);</span><br><span class="line"><span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][max_k + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = max_k; k &gt;= <span class="number">1</span>; k--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i - <span class="number">1</span> == -<span class="number">1</span>) &#123; <span class="comment">/* 处理 base case */</span> &#125;</span><br><span class="line">        dp[i][k][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line">        dp[i][k][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i]);     </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> dp[n - <span class="number">1</span>][max_k][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，6 道题目通过一个状态转移方程全部解决。</p><h3 id="4-最后总结"><a href="#4-最后总结" class="headerlink" title="4 最后总结"></a>4 最后总结</h3><p>本文给大家讲了如何通过状态转移的方法解决复杂的问题，用一个状态转移方程秒杀了 6 道股票买卖问题，现在想想，其实也不算难对吧？这已经属于动态规划问题中较困难的了。</p><p>关键就在于列举出所有可能的「状态」，然后想想怎么穷举更新这些「状态」。一般用一个多维 dp 数组储存这些状态，从 base case 开始向后推进，推进到最后的状态，就是我们想要的答案。想想这个过程，你是不是有点理解「动态规划」这个名词的意义了呢？</p><p>具体到股票买卖问题，我们发现了三个状态，使用了一个三维数组，无非还是穷举 + 更新，不过我们可以说的高大上一点，这叫「三维 DP」，怕不怕？这个大实话一说，立刻显得你高人一等，名利双收有没有。</p><p>所以，大家不要被各种高大上的名词吓到，再多的困难问题，奇技淫巧，也不过是基本套路的不断升级组合产生的。只要把住算法的底层原理，即可举一反三，逐个击破。</p><h3 id="5-相关题目"><a href="#5-相关题目" class="headerlink" title="5 相关题目"></a>5 相关题目</h3><p>[买卖股票的最佳时机][<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/</a>]</p><p>[买卖股票的最佳时机 II][<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/</a>]</p><p>[买卖股票的最佳时机 III][<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/</a>]</p><p>[买卖股票的最佳时机 IV][<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/</a>]</p><p>[最佳买卖股票时机含冷冻期][<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a>]</p><p>[买卖股票的最佳时机含手续费][<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/</a>]</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;文章为转载，侵删，仅供自己收藏&lt;/p&gt;
&lt;p&gt;[英文版][&lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems&quot;&gt;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems&lt;/a&gt;]&lt;br&gt;[中文版翻译][&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/&quot;&gt;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/&lt;/a&gt;]&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://www.jiangluyu.xyz/categories/LeetCode/"/>
    
    
      <category term="easy" scheme="https://www.jiangluyu.xyz/tags/easy/"/>
    
      <category term="medium" scheme="https://www.jiangluyu.xyz/tags/medium/"/>
    
      <category term="dp" scheme="https://www.jiangluyu.xyz/tags/dp/"/>
    
      <category term="hard" scheme="https://www.jiangluyu.xyz/tags/hard/"/>
    
  </entry>
  
  <entry>
    <title>M322-零钱兑换</title>
    <link href="https://www.jiangluyu.xyz/2020/03/08/M322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/"/>
    <id>https://www.jiangluyu.xyz/2020/03/08/M322-零钱兑换/</id>
    <published>2020-03-08T03:38:41.000Z</published>
    <updated>2021-08-16T18:16:27.720Z</updated>
    
    <content type="html"><![CDATA[<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。</p><a id="more"></a><p>如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>示例 1:</p><p>输入: coins = [1, 2, 5], amount = 11<br>输出: 3<br>解释: 11 = 5 + 5 + 1<br>示例 2:</p><p>输入: coins = [2], amount = 3<br>输出: -1<br>说明:<br>你可以认为每种硬币的数量是无限的。</p><h3 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><script type="math/tex; mode=display">dp(n)=\left \{\begin{array} \\-1, n \lt 0 \\0, n = 0 \\\min\{dp(n-coin) + 1 | coin \in coins \}, n \gt 0 \\\end{array}\right .</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(amount + <span class="number">1</span>, amount + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> size = amount + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - coin &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i] = min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (dp[amount] == amount + <span class="number">1</span>) ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法二：贪心-dfs"><a href="#方法二：贪心-dfs" class="headerlink" title="方法二：贪心+dfs"></a>方法二：贪心+dfs</h3><p><strong>贪心</strong></p><blockquote><p>想要总硬币数最少，肯定是优先用大面值硬币，所以对 coins 按从大到小排序</p><p>先丢大硬币，再丢会超过总额时，就可以递归下一层丢的是稍小面值的硬币</p></blockquote><p><strong>乘法对加法的加速</strong></p><blockquote><p>优先丢大硬币进去尝试，也没必要一个一个丢，可以用乘法算一下最多能丢几个</p><p>如果因为丢多了导致最后无法凑出总额，再回溯减少大硬币数量,最先找到的并不是最优解</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = amount / coins[cIdx] <span class="comment">// 计算最大能投几个</span></span><br><span class="line">amount - i * coins[cIdx] <span class="comment">// 减去扔了i个硬币</span></span><br><span class="line">count + i <span class="comment">// 加i个硬币</span></span><br></pre></td></tr></table></figure><p><strong>注意不是现实中发行的硬币，面值组合规划合理，会有奇葩情况</strong></p><blockquote><p>考虑到有 $[1,7,10]$ 这种用例，按照贪心思路$10 + 1 + 1 + 1 + 1$会比$7 + 7$更早找到，所以还是需要把所有情况都递归完</p></blockquote><p><strong>res 疯狂剪枝</strong></p><blockquote><p>贪心虽然得不到最优解，但也不是没用的</p><p>我们快速算出一个贪心的res之后，虽然还会有奇葩情况，但是绝大部分普通情况就可以疯狂剪枝了</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(coins.rbegin(), coins.rend());</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">        dfs(coins, amount, <span class="number">0</span>, <span class="number">0</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res == INT_MAX ? <span class="number">-1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount, <span class="keyword">int</span> cIdx, <span class="keyword">int</span> count, <span class="keyword">int</span>&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) &#123;</span><br><span class="line">            res = min(res, count);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cIdx == coins.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = amount / coins[cIdx]; i &gt;= <span class="number">0</span> &amp;&amp; count + i &lt; res; i--) &#123;</span><br><span class="line">            dfs(coins, amount - i * coins[cIdx], cIdx + <span class="number">1</span>, count + i, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://www.jiangluyu.xyz/categories/LeetCode/"/>
    
    
      <category term="medium" scheme="https://www.jiangluyu.xyz/tags/medium/"/>
    
      <category term="dp" scheme="https://www.jiangluyu.xyz/tags/dp/"/>
    
      <category term="greedy" scheme="https://www.jiangluyu.xyz/tags/greedy/"/>
    
  </entry>
  
  <entry>
    <title>今日母亲为我理发</title>
    <link href="https://www.jiangluyu.xyz/2020/02/29/%E4%BB%8A%E6%97%A5%E6%AF%8D%E4%BA%B2%E4%B8%BA%E6%88%91%E7%90%86%E5%8F%91/"/>
    <id>https://www.jiangluyu.xyz/2020/02/29/今日母亲为我理发/</id>
    <published>2020-02-28T17:57:53.000Z</published>
    <updated>2021-08-16T18:16:27.721Z</updated>
    
    <content type="html"><![CDATA[<p>因疫情缘故，</p><p>头发极长，</p><p>于是今日母亲用网购来的推子与剪子，</p><p>为我们爷俩剪了头，</p><p>十分满意。</p><p>父亲发型阴差阳错，</p><p>甚是新潮。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因疫情缘故，&lt;/p&gt;
&lt;p&gt;头发极长，&lt;/p&gt;
&lt;p&gt;于是今日母亲用网购来的推子与剪子，&lt;/p&gt;
&lt;p&gt;为我们爷俩剪了头，&lt;/p&gt;
&lt;p&gt;十分满意。&lt;/p&gt;
&lt;p&gt;父亲发型阴差阳错，&lt;/p&gt;
&lt;p&gt;甚是新潮。&lt;/p&gt;

      
    
    </summary>
    
      <category term="日常" scheme="https://www.jiangluyu.xyz/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="活在此时" scheme="https://www.jiangluyu.xyz/tags/%E6%B4%BB%E5%9C%A8%E6%AD%A4%E6%97%B6/"/>
    
  </entry>
  
  <entry>
    <title>C++set详解</title>
    <link href="https://www.jiangluyu.xyz/2020/02/27/C++set/"/>
    <id>https://www.jiangluyu.xyz/2020/02/27/C++set/</id>
    <published>2020-02-26T16:43:00.000Z</published>
    <updated>2021-08-16T18:16:27.717Z</updated>
    
    <content type="html"><![CDATA[<p>关于C++ STL set的用法以及知识延伸。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        nums.insert(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等效 set&lt;int&gt;::iterator it = nums.begin();</span></span><br><span class="line">    <span class="keyword">auto</span> it = nums.begin();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (it; it != nums.end(); it++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">begin() <span class="comment">// 返回指向set容器第一个元素的迭代器</span></span><br><span class="line"></span><br><span class="line">end() <span class="comment">// 返回指向set容器最后一个元素的迭代器，不存值</span></span><br><span class="line">    </span><br><span class="line">rbegin() <span class="comment">// 等效end()</span></span><br><span class="line">    </span><br><span class="line">rend() <span class="comment">// 等效begin()</span></span><br><span class="line">    </span><br><span class="line">clear() <span class="comment">// 清空set容器</span></span><br><span class="line">    </span><br><span class="line">empty() <span class="comment">// 判断set容器是否为空</span></span><br><span class="line">    </span><br><span class="line">max_size() <span class="comment">// 返回set容器可能包含元素的最大个数</span></span><br><span class="line">    </span><br><span class="line">size() <span class="comment">// 返回当前set容器中的元素个数</span></span><br><span class="line">    </span><br><span class="line">insert(x) <span class="comment">// 向set容器中插入值x，返回值为pair&lt;it, bool&gt;，bool表示是否成功，it指向x在set中的位置</span></span><br><span class="line">    </span><br><span class="line">insert(it_start, it_end) <span class="comment">// 向set中插入两迭代器中间的值</span></span><br><span class="line">    </span><br><span class="line">erase(x) <span class="comment">// 从set容器中删除值x，若x为迭代器，则删除迭代器指向的值</span></span><br><span class="line">    </span><br><span class="line">erase(it_start, it_end) <span class="comment">// 删除set中两迭代器中间的值，包括*it_start，不包括*it_end</span></span><br><span class="line">    </span><br><span class="line">count(x) <span class="comment">// 计算set中x出现的次数，在set中只可能为1或0</span></span><br><span class="line">    </span><br><span class="line">find(x) <span class="comment">// 若找到x，则返回指向x的迭代器，否则返回end()</span></span><br><span class="line">    </span><br><span class="line">lower_bound(x) <span class="comment">// 返回指向第一个大于等于x的值的迭代器</span></span><br><span class="line">    </span><br><span class="line">upper_bound(x) <span class="comment">// 返回指向第一个大于x的值的迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回pair&lt;it, it&gt;，即在两迭代器内，所有等于x的值的范围，即第一个x的位置与最后一个x的位置，set中若不存在x则两值相等</span></span><br><span class="line">equal_range(it_begin, it_end, x) </span><br><span class="line"></span><br><span class="line">set1.insert(set2.begin(), set3.end()) <span class="comment">// set1 = set2 ∪ set3 并去重</span></span><br><span class="line"></span><br><span class="line">set1.swap(set2) <span class="comment">// 两个set内容交换</span></span><br></pre></td></tr></table></figure><h3 id="知识延伸"><a href="#知识延伸" class="headerlink" title="知识延伸"></a>知识延伸</h3><h5 id="map和set插入删除效率比其他序列容器高的原因："><a href="#map和set插入删除效率比其他序列容器高的原因：" class="headerlink" title="map和set插入删除效率比其他序列容器高的原因："></a>map和set插入删除效率比其他序列容器高的原因：</h5><blockquote><p>底层实现为红黑树，对于关联容器来说，不需要做内存拷贝和内存移动。set容器内所有元素都是以节点的方式来存储，其节点结构和链表差不多，指向父节点和子节点。</p></blockquote><h5 id="map在每次insert、erase操作之后，以前的迭代器是否会过期？"><a href="#map在每次insert、erase操作之后，以前的迭代器是否会过期？" class="headerlink" title="map在每次insert、erase操作之后，以前的迭代器是否会过期？"></a>map在每次insert、erase操作之后，以前的迭代器是否会过期？</h5><blockquote><p>不会，注意vector在进行相应操作后迭代器可能会过期。</p></blockquote><h5 id="插入、搜索元素时，效率如何？"><a href="#插入、搜索元素时，效率如何？" class="headerlink" title="插入、搜索元素时，效率如何？"></a>插入、搜索元素时，效率如何？</h5><blockquote><p>set中使用的是二分查找，时间复杂度为<em>logn</em>，换言之，数据增大一倍时，搜索次数会多1次。</p></blockquote><h5 id="如何求并集、交集、差集、对称差集（A∪B-A∩B）？"><a href="#如何求并集、交集、差集、对称差集（A∪B-A∩B）？" class="headerlink" title="如何求并集、交集、差集、对称差集（A∪B-A∩B）？"></a>如何求并集、交集、差集、对称差集（A∪B-A∩B）？</h5><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// 交集</span></span><br><span class="line">&gt; set_intersection(it1_start, it1_end, it2_start, it2_end, inserter(res, res.begin()))</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// 差集</span></span><br><span class="line">&gt; set_difference(it1_start, it1_end, it2_start, it2_end, inserter(res, res.begin()))</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// 并集</span></span><br><span class="line">&gt; set_union(it1_start, it1_end, it2_start, it2_end, inserter(res, res.begin()))</span><br><span class="line">&gt;     </span><br><span class="line">&gt; <span class="comment">// 对称差集</span></span><br><span class="line">&gt; set_symmetry_difference(it1_start, it1_end, it2_start, it2_end, inserter(res, res.begin()))</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于C++ STL set的用法以及知识延伸。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="https://www.jiangluyu.xyz/categories/C/"/>
    
    
      <category term="算法" scheme="https://www.jiangluyu.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="STL" scheme="https://www.jiangluyu.xyz/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>E021-合并两个有序链表</title>
    <link href="https://www.jiangluyu.xyz/2020/02/21/E021-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>https://www.jiangluyu.xyz/2020/02/21/E021-合并两个有序链表/</id>
    <published>2020-02-21T15:08:27.000Z</published>
    <updated>2021-08-16T18:16:27.718Z</updated>
    
    <content type="html"><![CDATA[<p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><a id="more"></a><p>示例：</p><p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><h3 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><p>思路即每次挑选一个“头”节点，在剩下的节点中再递归挑选“头”节点，直至有一个链表被挑光，即为空。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li>时间复杂度：<em>O</em>(<em>m</em> + <em>n</em>)，<em>m</em>，<em>n</em>分别为<code>l1</code>,<code>l2</code>的元素个数。递归函数每次去掉一个元素，直到两个链表都为空，因此需要调用<em>R</em>=<em>O</em>(<em>m</em> + <em>n</em>)次。而在递归函数中我们只进行了<code>next</code>指针的赋值操作，复杂度为<em>O</em>(1)，故递归的总时间复杂度为<em>O</em>(<em>m</em> + <em>n</em>)。</li><li>空间复杂度：<em>O</em>(<em>m</em> + <em>n</em>)，递归调用了该函数<em>m</em> + <em>n</em>次，使用了<em>m</em> + <em>n</em>个栈帧，故空间复杂度为<em>O</em>(<em>m</em> + <em>n</em>)。</li></ul><hr><h3 id="方法二：迭代"><a href="#方法二：迭代" class="headerlink" title="方法二：迭代"></a>方法二：迭代</h3><p>用一个<code>prev</code>指针维护当前接在结果中的最后一个节点，每次迭代要做的就是决定<code>l1</code>与<code>l2</code>中哪一个的剩余头节点成为<code>prev-&gt;next</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* resHead = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            resHead = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            resHead = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* prev = resHead;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                prev-&gt;next = l1;</span><br><span class="line">                prev = prev-&gt;next;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                prev-&gt;next = l2;</span><br><span class="line">                prev = prev-&gt;next;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            prev-&gt;next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            prev-&gt;next = l1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li>时间复杂度：<em>O</em>(<em>m</em> + <em>n</em>)，<em>m</em>，<em>n</em>分别为<code>l1</code>,<code>l2</code>的元素个数，相当于遍历了两次较短链表的长度。</li><li>空间复杂度：<em>O</em>(1)，每次迭代只使用了同一个<code>prev</code>指针，因此为常数级复杂度。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 &lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://www.jiangluyu.xyz/categories/LeetCode/"/>
    
    
      <category term="easy" scheme="https://www.jiangluyu.xyz/tags/easy/"/>
    
      <category term="recursion" scheme="https://www.jiangluyu.xyz/tags/recursion/"/>
    
      <category term="iteration" scheme="https://www.jiangluyu.xyz/tags/iteration/"/>
    
  </entry>
  
  <entry>
    <title>电脑维修实用问题汇总</title>
    <link href="https://www.jiangluyu.xyz/2020/02/21/%E7%94%B5%E8%84%91%E7%BB%B4%E4%BF%AE%E5%AE%9E%E7%94%A8%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>https://www.jiangluyu.xyz/2020/02/21/电脑维修实用问题汇总/</id>
    <published>2020-02-21T10:51:37.000Z</published>
    <updated>2021-08-16T18:16:27.725Z</updated>
    
    <content type="html"><![CDATA[<p>一些常用问题汇总。</p><a id="more"></a><h2 id="实用问题汇总："><a href="#实用问题汇总：" class="headerlink" title="实用问题汇总："></a>实用问题汇总：</h2><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><ul><li>进水<ul><li>进水的问题一定要<strong>马上和机主联系</strong>，不可耽误，如果<strong>没法第一时间接单，就让机主马上送去维修</strong>，或者将单子转给别的技术员，总之<strong>处理要快</strong></li><li>询问机主是<strong>什么时候进的水？进的是什么水？进了多少水？进水之后做了什么？</strong>（如果遇上神仙机主，机子进水了还不拆开开始晒干，等过了一两天才找你，甚至进完水没多久觉得可以了还开机的，这种单子最好就别接了）</li><li>如果还来得及，提醒机主<strong>一定不能开机</strong>，再接到机子后，首先把电源拆掉（个人建议这里别放静电，放了有可能出事），如果发现进水量过大，已经渗入主板内，先用纸把周围的水吸附掉，把硬盘拆下来（电脑出问题优先保住硬盘），继续吸附水，然后接着拆，以此循环，把能吸附的水吸附掉后，视情况建议机主送去维修店烘干。如果倒入的是饮料。。。尽力而为吧，某些地方可以用酒精纸（不过多半救不了），同样能处理完后让机主送去维修</li><li>如果以上更糟糕的情况没有发生，则将拆开后的本子和配件放在通风处（不能让阳光直射），等待晾干，原则上是至少要晾3天</li></ul></li><li>清灰<ul><li>顺序：拆机→清理风扇→清理其他→装机</li><li>注意：<strong>分清螺丝</strong>、视电脑拆机难度，决定拆机层次，结构比较复杂的尽量降低拆机的层次（但依然要<strong>把电池拆下来</strong>）、用皮老虎，角度尽量贴近风扇平面，<strong>对着扇叶吹</strong>，吹的方向应该是风扇靠近笔记本边缘的方向，以免吹出来的灰尘落到元件上，吹的过程中可<strong>用小刷子擦拭扇叶</strong>，帮助清理。吹完后，用小刷子轻轻扫过平面，将残留的灰尘扫出去。最后用皮老虎再吹，如果基本没有灰尘吹出，则差不多清理完毕</li></ul></li><li>花屏<ul><li>有能力的可以拆屏幕框重新插拔排线，否则直接建议机主售后</li></ul></li><li>扩容<ul><li>硬盘：注意主板接口与硬盘<strong>接口是否匹配</strong>（要熟知常见的接口！）</li><li>内存：注意内存的<strong>接口类型</strong>（DDR3、DDR3L、DDR4）以及<strong>频率</strong>（向下兼容，按最低的算）</li></ul></li></ul><h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><ul><li>系统<ul><li>系统镜像去MSDN下载原版</li><li>制作PE盘（去微PE官网下载或使用飞扬的镜像，其实是一个东西）</li><li>激活使用KMS（建议使用胡萝卜周博客中下载的版本）</li></ul></li><li>常用软件（常备安装文件！安装失败时注意错误代码！）<ul><li>驱动人生、驱动精灵，重装电脑时使用装机版，其他情况下只有当有问题时才尝试升级、重装驱动，不要随意升级其他正常工作的驱动！</li><li>Microsoft Office</li><li>Adobe</li><li>AutoCAD</li></ul></li></ul><p>注：在安装CAD等软件过程中报错，比起直接搜索“安装到哪里不动“”安装XXX出错”，先查看这类软件的安装日志，看看安装日志是在哪一步失败，再推断和搜索安装原因是最高效、最准确的（如果你找得到安装日志的话，大部分的软件应该都有，因为写他们的程序员自己也要看）</p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="Q1：网页打不开"><a href="#Q1：网页打不开" class="headerlink" title="Q1：网页打不开"></a>Q1：网页打不开</h4><ul><li>检查<strong>网络连接是否正常</strong></li><li>检查<strong>是否启动代理</strong>（SSR之类），小飞机启动后选择关闭有时也会导致无法打开网页</li><li>检查<strong>防火墙设置</strong>，将浏览器或其他连不了网络的软件添加至<em>例外</em>中</li><li><strong>清除缓存与Cookie信息</strong>[IE中：工具→Internet选项→常规→浏览历史记录→删除]，CC登不上时常用</li><li>使用<strong>360断网急救箱</strong></li></ul><h4 id="Q2：蓝牙连不上"><a href="#Q2：蓝牙连不上" class="headerlink" title="Q2：蓝牙连不上"></a>Q2：蓝牙连不上</h4><ul><li>检查<strong>是否打开蓝牙</strong></li><li>检查<strong>是否开了飞行模式</strong>而自动关闭蓝牙</li><li><strong>查看蓝牙驱动</strong>[设备管理器→蓝牙]，哪里不对，更新哪里</li><li><strong>Win+R</strong>打开运行，输入<strong>services.msc</strong>，查看其中与蓝牙有关的服务项（如Bluetooth Support Service），如果有禁用的，则<strong>改为自动启动</strong></li><li>麻烦的情况：能做的都做了，重启后有时可以有时不行（大概率在冬天），这是一个玄学问题，售后或者一般等天气回暖就好了</li></ul><h4 id="Q3：广告弹窗"><a href="#Q3：广告弹窗" class="headerlink" title="Q3：广告弹窗"></a>Q3：广告弹窗</h4><ul><li>打开任务管理器，定位弹窗广告的进程，右键选择“打开文件所在的位置”，打开后删掉或者卸载相关文件，并关掉对应的进程便可</li><li>如果不能确定哪个进程是弹窗广告的话，要进行试错，选择从没见过、从命名不能理解进程用途、非系统文件命名方式的进程，先打开文件所在位置，然后关掉进程，如果弹窗消失，说明找到了</li><li>部分弹窗运行文件删除的时候可能没有权限（真的非常流氓），可以进入Window10的安全模式（<strong>Win+R</strong>，输入<strong>msconfig</strong>，勾选<strong>安全引导</strong>，点击<strong>确定</strong>，<strong>重启</strong>电脑便好），再去相应的文件位置删除（安全模式能够自动获取权限）</li><li>如果机主反馈弹窗又重新出现，你发现原来的弹窗文件又生成了，而机主又不愿意卸载使其生成的软件（以金山毒霸为首），那么可以使用“偷天换日”的做法：复制弹窗对应的exe文件的文件名，将原来的文件删掉后，在原来的位置新建立一个txt文件，将文件名改为复制的文件名（记得修改后缀），然后右键改文件，点击“属性”，在“安全”中点击编辑，在权限窗口中勾选“拒绝”一栏，这样当软件想要读取的时候就会“哑火”</li><li>具体可参照这个链接：<a href="https://jingyan.baidu.com/article/3a2f7c2e51d76d67afd611be.html">https://jingyan.baidu.com/article/3a2f7c2e51d76d67afd611be.html</a></li><li>常见的弹窗系软件：360系，爱奇艺，腾讯视频，2345系（好压、看图王等），搜狐系</li><li>懒人法：火绒的弹窗管理</li></ul><h4 id="Q4：电脑启动慢、卡顿"><a href="#Q4：电脑启动慢、卡顿" class="headerlink" title="Q4：电脑启动慢、卡顿"></a>Q4：电脑启动慢、卡顿</h4><ul><li>若电脑服役时间较久（有的甚至是没有SSD的年代的电脑），最好选择硬件升级</li><li>启动慢修改开机启动项：<strong>Win+R</strong>，输入<strong>msconfig</strong>，在<em>常规</em>一栏中选择有选择的启动，并勾选<em>加载启动项</em>，到<em>启动</em>一栏中对启动项进行调整</li><li>懒人法：火绒的启动项管理</li></ul><h4 id="Q5：系统重装"><a href="#Q5：系统重装" class="headerlink" title="Q5：系统重装"></a>Q5：系统重装</h4><ul><li>注意事项：询问机主是否需要<strong>备份</strong>，以及重装后<strong>需要重新安装的软件</strong></li></ul><h4 id="Q6：电脑没声音"><a href="#Q6：电脑没声音" class="headerlink" title="Q6：电脑没声音"></a>Q6：电脑没声音</h4><ul><li><strong>使用声音疑难解答</strong>[声音图标（右键）→声音问题疑难解答]（这个检测出的问题常常可以作为百度的关键词，比直接搜索问题要精准一点）</li><li><strong>设置扬声器为默认设备</strong>[声音图标（右键）→打开音量合成器→系统声音→播放]</li><li><strong>扬声器还原默认值</strong>[扬声器（右键）→高级→还原默认值]</li><li><strong>检查驱动</strong>[开始图标右键→设备管理器（快捷键Win+X, M）→声音、视频和游戏控制器设备管理器→Realtek High Definition Audio（或Realtek Audio）]，使用驱动精灵进行重装或更新</li><li>存在特殊情况：笔记本插上耳机有声音，外放没声音。在以上方法排除后，依然出现这种情况，那么打开设备管理器，点击系统设备，找到英特尔智音技术控制器，右键点击选择更新驱动就好了，再选择“自动搜索”或者“浏览计算机”，如果是后者的话，应该选择的驱动是High Definition Audio（这个我找不到之前的解决链接了，按照记忆写了一下，找“智音技术”准没错）</li></ul><h4 id="Q7：连不上网"><a href="#Q7：连不上网" class="headerlink" title="Q7：连不上网"></a>Q7：连不上网</h4><ul><li>无线网：（以下方法按顺序进行，若都无效可能是硬件问题，建议售后）</li></ul><ol><li>查看<strong>是否进入了飞行模式</strong>[右下角网络图标→飞行模式]</li><li>查看<strong>设备管理器中的驱动状态</strong>[左下角开始图标右键→设备管理器（快捷键Win+X, M）→网络适配器]，有线网一般是带有<em>PCIe</em>的字样，无线网一般是带有<em>Wireless</em>，如果对应驱动出现<em>红叉</em>或者<em>警告标志</em>，一般是驱动出了问题，更新或者重新安装就行了，没有的话，直接尝试重新安装</li><li>使用系统自带的<strong>疑难解答</strong>[右下角网络图标→设置→网络疑难解答]</li><li>尝试<strong>360断网急救箱</strong></li><li><strong>Win+R</strong>打开运行，输入<strong>cmd</strong>，在命令提示符中<strong>输入命令回车并重启</strong>：</li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh winsock reset</span><br></pre></td></tr></table></figure><ol><li>较为麻烦的情况：网络列表上<strong>没有可连接的网络</strong>，设备管理器中<strong>找不到对应驱动</strong>，甚至在”网络和Internet”上<strong>找不到<em>WLAN</em>等表项</strong>，驱动精灵安装驱动时<strong>没有安装网卡驱动的选项</strong>，而且机主告诉你，他<strong>无线能用但有线不能或者反之或者皆不能</strong>，说明很有可能<strong>网卡硬件出了问题</strong>，拆机后<strong>对网卡重新插拔</strong>（注意记住连接网卡的两个小细线，连接的顺序和位置不能错）。要注意这个可插拔的网卡只管无线网！因此如果你再重新插拔后无线网依然没法用，或者以上情况中的主体是有线网，那么恭喜你，这电脑很有可能就修不好了（参照刘双嘉同学亲身经历）。这个麻烦情况大都出现在冬天，初步推断是硬件老化加上热胀冷缩引起的，建议送报修或者售后。</li></ol><ul><li>有线网：（以下方法按顺序进行，若都无效可能是硬件问题，建议售后）</li></ul><ol><li><p>检查<strong>网线是否插好</strong>，若仍提示<em>网络电缆未插入</em>可以尝试更换网线</p></li><li><p>使用系统自带的<strong>疑难解答</strong>[右下角网络图标→设置→网络疑难解答]</p></li><li><p>尝试<strong>360断网急救箱</strong></p></li><li><p><strong>Win+R</strong>打开运行，输入<strong>cmd</strong>，在命令提示符中<strong>输入命令回车并重启</strong>：</p></li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh winsock reset</span><br></pre></td></tr></table></figure><ol><li>使用驱动精灵/驱动人生<strong>重新安装网卡驱动</strong></li></ol><h3 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h3><p>除了动手以外，想做“好”的一定要对笔记本参数保持敏感，经常学习。</p><p>下面是一些推荐的信息源：</p><p>公众号：笔吧评测室</p><p>b站：翼王，Linus等</p><h3 id="常用资源-软件安装"><a href="#常用资源-软件安装" class="headerlink" title="常用资源[软件安装]"></a>常用资源[软件安装]</h3><ul><li>微信公众号：软件安装管家</li><li>胡萝卜周博客（右上角放大镜检索）：<a href="http://www.carrotchou.blog">http://www.carrotchou.blog</a></li><li>MSDN：<a href="https://msdn.itellyou.cn/">https://msdn.itellyou.cn/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些常用问题汇总。&lt;/p&gt;
    
    </summary>
    
      <category term="电脑维修" scheme="https://www.jiangluyu.xyz/categories/%E7%94%B5%E8%84%91%E7%BB%B4%E4%BF%AE/"/>
    
    
      <category term="问题汇总" scheme="https://www.jiangluyu.xyz/tags/%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    
  </entry>
  
  <entry>
    <title>独立口语思路练习模板</title>
    <link href="https://www.jiangluyu.xyz/2020/02/15/%E7%8B%AC%E7%AB%8B%E5%8F%A3%E8%AF%AD%E6%80%9D%E8%B7%AF%E7%BB%83%E4%B9%A0%E6%A8%A1%E6%9D%BF/"/>
    <id>https://www.jiangluyu.xyz/2020/02/15/独立口语思路练习模板/</id>
    <published>2020-02-15T14:52:49.000Z</published>
    <updated>2022-02-22T18:22:16.291Z</updated>
    
    <content type="html"><![CDATA[<p>新托福口语思路练习模板。</p><a id="more"></a><h3 id="Q1-Smart-phone-amp-navigational-devices-or-ask-the-locals-for-direction"><a href="#Q1-Smart-phone-amp-navigational-devices-or-ask-the-locals-for-direction" class="headerlink" title="Q1: Smart phone &amp; navigational devices or ask the locals for direction?"></a>Q1: Smart phone &amp; navigational devices or ask the locals for direction?</h3><p><strong>Main idea:</strong> the former</p><p><strong>Reason 1:</strong> professional —&gt; accurate, efficient</p><p><strong>Example 1:</strong> locals maybe do not know or give obsolete information —&gt; slower, while navigational devices are always up-to-date</p><p><strong>Reason 2: </strong>no need to care about language problem</p><p><strong>Example 2:</strong> cannot speak Japanese, Last year travel to Japan, Google Map —&gt; not miss any event planned</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新托福口语思路练习模板。&lt;/p&gt;
    
    </summary>
    
      <category term="TOEFL" scheme="https://www.jiangluyu.xyz/categories/TOEFL/"/>
    
    
      <category term="口语" scheme="https://www.jiangluyu.xyz/tags/%E5%8F%A3%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>托福口语答题模板</title>
    <link href="https://www.jiangluyu.xyz/2020/02/15/%E6%89%98%E7%A6%8F%E7%AD%94%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    <id>https://www.jiangluyu.xyz/2020/02/15/托福答题模板/</id>
    <published>2020-02-15T14:32:57.000Z</published>
    <updated>2022-02-22T15:12:48.786Z</updated>
    
    <content type="html"><![CDATA[<p>新托福口语答题模板总结。</p><a id="more"></a><h3 id="TASK-1"><a href="#TASK-1" class="headerlink" title="TASK 1"></a>TASK 1</h3><pre class="mermaid">graph TD;  A(Main idea)-->B(Reason 1)-->C(Reason 2)</pre><p>Template:</p><blockquote><p>When …, I’d …/Well honestly, I (dis)agree with the idea.</p><p>The most obvious reason is that + sub idea 1.</p><p>In my case/Take my own experience for example, …</p><p>Another reason is that + sub idea 2.</p><p>To be more specific/Specifically speaking,…</p><p>(Those are the reasons why I am for/against the idea.)</p></blockquote><h3 id="TASK-2"><a href="#TASK-2" class="headerlink" title="TASK 2"></a>TASK 2</h3><p>Template:</p><blockquote><p>UNIV：</p><ul><li>The university is going to/announces that…because/in order to…</li></ul><p>S/T：</p><ul><li>A student/teacher suggests university should…because/in order to…</li></ul><p>The man/woman (dis)agrees with the idea.</p><p>He/She says that…</p></blockquote><h3 id="TASK-3"><a href="#TASK-3" class="headerlink" title="TASK 3"></a>TASK 3</h3><p>Template:</p><blockquote><p>The passage defines X as n. that…</p><p>The professor elaborates on this with an example.</p><p>…</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新托福口语答题模板总结。&lt;/p&gt;
    
    </summary>
    
      <category term="TOEFL" scheme="https://www.jiangluyu.xyz/categories/TOEFL/"/>
    
    
      <category term="口语" scheme="https://www.jiangluyu.xyz/tags/%E5%8F%A3%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>关于hexo遇到的问题汇总</title>
    <link href="https://www.jiangluyu.xyz/2020/02/15/%E5%85%B3%E4%BA%8Ehexo%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>https://www.jiangluyu.xyz/2020/02/15/关于hexo遇到的问题汇总/</id>
    <published>2020-02-15T11:02:17.000Z</published>
    <updated>2021-08-16T18:16:27.722Z</updated>
    
    <content type="html"><![CDATA[<p>一些迁移、安装hexo时遇到的问题及解决方法。</p><a id="more"></a><h3 id="Q1-gyp-No-Xcode-or-CLT-version-detected"><a href="#Q1-gyp-No-Xcode-or-CLT-version-detected" class="headerlink" title="Q1: gyp: No Xcode or CLT version detected!"></a>Q1: gyp: No Xcode or CLT version detected!</h3><p>近日在将hexo从win迁移到mac时，卡在了npm安装上：</p><p>运行如下命令时：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>出现如下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&gt; node install</span><br><span class="line"></span><br><span class="line">node-pre-gyp WARN Tried to download(404): https://fsevents-binaries.s3-us-west-2.amazonaws.com/v1.2.4/fse-v1.2.4-node-v67-darwin-x64.tar.gz</span><br><span class="line">node-pre-gyp WARN Pre-built binaries not found <span class="keyword">for</span> fsevents@1.2.4 and node@11.14.0 (node-v67 ABI, unknown) (falling back to <span class="built_in">source</span> compile with node-gyp)</span><br><span class="line">No receipt <span class="keyword">for</span> <span class="string">'com.apple.pkg.CLTools_Executables'</span> found at <span class="string">'/'</span>.</span><br><span class="line"></span><br><span class="line">No receipt <span class="keyword">for</span> <span class="string">'com.apple.pkg.DeveloperToolsCLILeo'</span> found at <span class="string">'/'</span>.</span><br><span class="line"></span><br><span class="line">No receipt <span class="keyword">for</span> <span class="string">'com.apple.pkg.DeveloperToolsCLI'</span> found at <span class="string">'/'</span>.</span><br><span class="line"></span><br><span class="line">gyp: No Xcode or CLT version detected!</span><br><span class="line">gyp ERR! configure error</span><br><span class="line">gyp ERR! stack Error: `gyp` failed with <span class="built_in">exit</span> code: 1</span><br><span class="line">gyp ERR! stack     at ChildProcess.onCpExit (/usr/<span class="built_in">local</span>/lib/node_modules/npm/node_modules/node-gyp/lib/configure.js:351:16)</span><br><span class="line">gyp ERR! stack     at ChildProcess.emit (events.js:193:13)</span><br><span class="line">gyp ERR! stack     at Process.ChildProcess._handle.onexit (internal/child_process.js:255:12)</span><br><span class="line">gyp ERR! System Darwin 19.3.0</span><br><span class="line">gyp ERR! <span class="built_in">command</span> <span class="string">"/usr/local/Cellar/node/11.14.0/bin/node"</span> <span class="string">"/usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js"</span> <span class="string">"configure"</span> <span class="string">"--fallback-to-build"</span> <span class="string">"--module=/Users/louis/Documents/GitHub/jiangluyu.github.io/node_modules/fsevents/lib/binding/Release/node-v67-darwin-x64/fse.node"</span> <span class="string">"--module_name=fse"</span> <span class="string">"--module_path=/Users/louis/Documents/GitHub/jiangluyu.github.io/node_modules/fsevents/lib/binding/Release/node-v67-darwin-x64"</span> <span class="string">"--napi_version=4"</span> <span class="string">"--node_abi_napi=napi"</span></span><br><span class="line">gyp ERR! cwd /Users/louis/Documents/GitHub/jiangluyu.github.io/node_modules/fsevents</span><br><span class="line">gyp ERR! node -v v11.14.0</span><br><span class="line">gyp ERR! node-gyp -v v5.0.7</span><br><span class="line">gyp ERR! not ok</span><br><span class="line">node-pre-gyp ERR! build error</span><br><span class="line">node-pre-gyp ERR! stack Error: Failed to execute <span class="string">'/usr/local/Cellar/node/11.14.0/bin/node /usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js configure --fallback-to-build --module=/Users/louis/Documents/GitHub/jiangluyu.github.io/node_modules/fsevents/lib/binding/Release/node-v67-darwin-x64/fse.node --module_name=fse --module_path=/Users/louis/Documents/GitHub/jiangluyu.github.io/node_modules/fsevents/lib/binding/Release/node-v67-darwin-x64 --napi_version=4 --node_abi_napi=napi'</span> (1)</span><br><span class="line">node-pre-gyp ERR! stack     at ChildProcess.&lt;anonymous&gt; (/Users/louis/Documents/GitHub/jiangluyu.github.io/node_modules/fsevents/node_modules/node-pre-gyp/lib/util/compile.js:83:29)</span><br><span class="line">node-pre-gyp ERR! stack     at ChildProcess.emit (events.js:193:13)</span><br><span class="line">node-pre-gyp ERR! stack     at maybeClose (internal/child_process.js:999:16)</span><br><span class="line">node-pre-gyp ERR! stack     at Process.ChildProcess._handle.onexit (internal/child_process.js:266:5)</span><br><span class="line">node-pre-gyp ERR! System Darwin 19.3.0</span><br><span class="line">node-pre-gyp ERR! <span class="built_in">command</span> <span class="string">"/usr/local/Cellar/node/11.14.0/bin/node"</span> <span class="string">"/Users/louis/Documents/GitHub/jiangluyu.github.io/node_modules/fsevents/node_modules/node-pre-gyp/bin/node-pre-gyp"</span> <span class="string">"install"</span> <span class="string">"--fallback-to-build"</span></span><br><span class="line">node-pre-gyp ERR! cwd /Users/louis/Documents/GitHub/jiangluyu.github.io/node_modules/fsevents</span><br><span class="line">node-pre-gyp ERR! node -v v11.14.0</span><br><span class="line">node-pre-gyp ERR! node-pre-gyp -v v0.10.0</span><br><span class="line">node-pre-gyp ERR! not ok</span><br><span class="line">Failed to execute <span class="string">'/usr/local/Cellar/node/11.14.0/bin/node /usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js configure --fallback-to-build --module=/Users/louis/Documents/GitHub/jiangluyu.github.io/node_modules/fsevents/lib/binding/Release/node-v67-darwin-x64/fse.node --module_name=fse --module_path=/Users/louis/Documents/GitHub/jiangluyu.github.io/node_modules/fsevents/lib/binding/Release/node-v67-darwin-x64 --napi_version=4 --node_abi_napi=napi'</span> (1)</span><br><span class="line">...以下省略</span><br></pre></td></tr></table></figure><p>实际上，在尝试过使用如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure><p>进行修复时，并不成功。</p><p><strong>解决方案如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf $(xcode-select -<span class="built_in">print</span>-path)</span><br><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure><h3 id="Q2-hexo迁移"><a href="#Q2-hexo迁移" class="headerlink" title="Q2: hexo迁移"></a>Q2: hexo迁移</h3><p>去年在原先的笔记本上建立的项目，彼时对github了解甚少，没想过在不同电脑上更新的需求，甚至还因此断更了一年（笑），迁移步骤如下：</p><p>ssh配置好后，克隆github上yourname.github.io项目到本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/yourname/yourname.github.io.git</span><br></pre></td></tr></table></figure><p>删除除了.git以外的所有文件；</p><p>将blog源文件中的所有文件复制到xxx.github.io的文件夹中，并将theme文件夹中各个主题中的.git文件夹删除；</p><p>创建hexo分支，并切换到hexo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b hexo</span><br></pre></td></tr></table></figure><p>将复制的文件提交到暂存区，并提交，推送至github：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">'new branch source files'</span></span><br><span class="line">git push --<span class="built_in">set</span>-upstream origin hexo</span><br></pre></td></tr></table></figure><p>更新blog时，只需要照常即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><p>切换至新电脑时，只需要执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b hexo https://github.com/yourname/yourname.github.io</span><br></pre></td></tr></table></figure><p>在ssh配置正确，npm安装依赖后，即可更新。</p><h3 id="Q3-无法备份-themes"><a href="#Q3-无法备份-themes" class="headerlink" title="Q3: 无法备份/themes"></a>Q3: 无法备份/themes</h3><p>在删掉themes中的所有主题的.git之后，发现使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git comment -m <span class="string">'write your comment here'</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>依然无法成功将自己修改过的主题提交到github上。</p><h5 id="解决方案如下："><a href="#解决方案如下：" class="headerlink" title="解决方案如下："></a>解决方案如下：</h5><p>在确保删除了各个主题的.git文件后，执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached -r themes</span><br><span class="line">git add themes</span><br><span class="line">git commit -m <span class="string">'write your comment here'</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些迁移、安装hexo时遇到的问题及解决方法。&lt;/p&gt;
    
    </summary>
    
      <category term="bugfix" scheme="https://www.jiangluyu.xyz/categories/bugfix/"/>
    
    
  </entry>
  
  <entry>
    <title>E867-转置矩阵</title>
    <link href="https://www.jiangluyu.xyz/2020/02/14/E867-%E8%BD%AC%E7%BD%AE%E7%9F%A9%E9%98%B5/"/>
    <id>https://www.jiangluyu.xyz/2020/02/14/E867-转置矩阵/</id>
    <published>2020-02-14T07:31:56.000Z</published>
    <updated>2021-08-16T18:16:27.719Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个矩阵 A， 返回 A 的转置矩阵。</p><p>矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。</p><a id="more"></a><p>示例 1：</p><p>输入：[[1,2,3],[4,5,6],[7,8,9]]<br>输出：[[1,4,7],[2,5,8],[3,6,9]]<br>示例 2：</p><p>输入：[[1,2,3],[4,5,6]]<br>输出：[[1,4],[2,5],[3,6]]</p><p>提示：</p><p>1 &lt;= A.length &lt;= 1000<br>1 &lt;= A[0].length &lt;= 1000</p><h3 id="方法一：遍历复制"><a href="#方法一：遍历复制" class="headerlink" title="方法一：遍历复制"></a>方法一：遍历复制</h3><p>重新创建一个vector，依照规律遍历并复制对应数字到所创建的vector中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; transpose(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A) &#123;</span><br><span class="line">        <span class="keyword">int</span> col = A[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> row = A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(col);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> iRow = <span class="number">0</span>; iRow &lt; col; iRow++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> iCol = <span class="number">0</span>; iCol &lt; row; iCol++)</span><br><span class="line">            &#123;</span><br><span class="line">                res[iRow].push_back(A[iCol][iRow]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li>时间复杂度：<em>O</em>(<em>M</em>×<em>N</em>)，其中<em>M</em>与<em>N</em>分别为矩阵<em>A</em>的行数和列数。</li><li>空间复杂度：<em>O</em>(<em>M</em>×<em>N</em>)。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个矩阵 A， 返回 A 的转置矩阵。&lt;/p&gt;
&lt;p&gt;矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://www.jiangluyu.xyz/categories/LeetCode/"/>
    
    
      <category term="easy" scheme="https://www.jiangluyu.xyz/tags/easy/"/>
    
      <category term="iteration" scheme="https://www.jiangluyu.xyz/tags/iteration/"/>
    
  </entry>
  
  <entry>
    <title>E206-反转链表</title>
    <link href="https://www.jiangluyu.xyz/2020/02/14/E206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>https://www.jiangluyu.xyz/2020/02/14/E206-反转链表/</id>
    <published>2020-02-13T16:35:27.000Z</published>
    <updated>2021-08-16T18:16:27.718Z</updated>
    
    <content type="html"><![CDATA[<p>反转一个单链表。</p><a id="more"></a><p>示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><h3 id="方法一：外部容器"><a href="#方法一：外部容器" class="headerlink" title="方法一：外部容器"></a>方法一：外部容器</h3><p>将链表转存至新的容器vector内，再利用vector本身的reverse_iterator进行反向遍历，将内容一一对应存入链表节点内。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; store;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            store.push_back(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* resHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* p = resHead;</span><br><span class="line">        ListNode* q = <span class="literal">nullptr</span>;</span><br><span class="line">        p-&gt;val = *(store.rbegin());</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator riter = store.rbegin() + <span class="number">1</span>; riter != store.rend(); riter++)</span><br><span class="line">        &#123;</span><br><span class="line">            q = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            q-&gt;val = *riter;</span><br><span class="line">            p-&gt;next = q;</span><br><span class="line">            p = q;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> resHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li>时间复杂度：<em>O</em>(<em>n</em>)，其中<em>n</em>为链表长度。</li><li>空间复杂度：<em>O</em>(<em>n</em>)。</li></ul><h3 id="方法二：迭代"><a href="#方法二：迭代" class="headerlink" title="方法二：迭代"></a>方法二：迭代</h3><p>在遍历列表时，将当前节点的 next 指针改为指向它的前一个节点。分别需要一个指针用来记录上一个节点（previous），当前节点（current）以及下一个节点（next）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* nextTemp = <span class="literal">nullptr</span>;</span><br><span class="line">            nextTemp = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li>时间复杂度：<em>O</em>(<em>n</em>)，其中<em>n</em>为链表长度。</li><li>空间复杂度：<em>O</em>(1)。</li></ul><h3 id="方法三：递归"><a href="#方法三：递归" class="headerlink" title="方法三：递归"></a>方法三：递归</h3><p>递归方法比较难理解，假设我们传入的链表为<code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>，那么传入的<code>head</code>即节点<code>1</code>，递归令节点<code>curr</code>等于<code>reverseList(head-&gt;next)</code>，终止条件为<code>head或head-&gt;next为空</code>，并返回<code>head</code>。</p><p>在这个例子中，最后一层返回的即节点<code>5</code>，此时<code>head</code>指向节点<code>4</code>，我们令<code>head-&gt;next-&gt;next = head</code>，即<code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;4</code>：</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/01.png" alt="01"></p><p>接着，令<code>head-&gt;next = null</code>，即<code>1-&gt;2-&gt;3-&gt;4-&gt;null</code>且<code>5-&gt;4</code>： </p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/02.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* curr = reverseList(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li>时间复杂度：<em>O</em>(<em>n</em>)，其中<em>n</em>为链表长度。</li><li>空间复杂度：<em>O</em>(<em>n</em>)，递归至<em>n</em>层。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;反转一个单链表。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://www.jiangluyu.xyz/categories/LeetCode/"/>
    
    
      <category term="easy" scheme="https://www.jiangluyu.xyz/tags/easy/"/>
    
      <category term="recursion" scheme="https://www.jiangluyu.xyz/tags/recursion/"/>
    
      <category term="iteration" scheme="https://www.jiangluyu.xyz/tags/iteration/"/>
    
      <category term="vector" scheme="https://www.jiangluyu.xyz/tags/vector/"/>
    
  </entry>
  
  <entry>
    <title>少少</title>
    <link href="https://www.jiangluyu.xyz/2019/01/04/%E5%B0%91%E5%B0%91/"/>
    <id>https://www.jiangluyu.xyz/2019/01/04/少少/</id>
    <published>2019-01-03T16:05:16.000Z</published>
    <updated>2021-08-16T18:16:27.722Z</updated>
    
    <content type="html"><![CDATA[<p>“如果提前了解了你们的人生，不知你们是否还会有勇气前来？”</p><a id="more"></a><hr><p>再想起这句台词，电影都不知是何日看的了，挺早的。</p><p>我想说，有啊，就是少点。</p><p>2018-2019的交界时，立了好多flag，还试着跟一波朋友圈网易云音乐flag的热潮，无奈轰趴的那个夜晚，明明显示着长按保存，我却怎么样都唤不出菜单。怎么回事？谁知道呢。我只知道，最后我放弃了，只在总结里添了一行信号微弱的粗浅论调。熬夜的后遗症还在，大致就是睡不醒醒就睡，萎靡着，空洞着，压缩着吃饭、喝水等等一切行动的欲望来恢复精力。</p><p>打卡到最后几个眼神都是迷离的，隐隐听着音响里的歌，再也不循环那个熟悉的、混杂的歌单了，随便什么，有声音就好，不是神曲就好，一个人的世界里，它们都有自己的声音。</p><p>喜欢美短，想取个名字叫辛巴(Simba)，而所有的不喜欢和不知道，是还没准备好。</p><p>出门就是一场义无反顾的冒险，不消多远，上厕所都赶时间，怕残羹被收走。相信世间温暖，禁不住旁人冷漠，观察得更多，想得更多，连绝对不常用的“plover”都变得难以忘记，才发现所谓的幸运四叶草，也只不过是“four-leaf clover”（四叶的三叶草）而已。</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200303015834.jpg" alt="入水"></p><p>幸好，镜头下死水微澜，是小野鸭在凫水。</p><p>不要等风来，跑起来，它就奔向了你。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;“如果提前了解了你们的人生，不知你们是否还会有勇气前来？”&lt;/p&gt;
    
    </summary>
    
      <category term="随便写写" scheme="https://www.jiangluyu.xyz/categories/%E9%9A%8F%E4%BE%BF%E5%86%99%E5%86%99/"/>
    
    
      <category term="随想" scheme="https://www.jiangluyu.xyz/tags/%E9%9A%8F%E6%83%B3/"/>
    
      <category term="生活" scheme="https://www.jiangluyu.xyz/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>不问归期来路</title>
    <link href="https://www.jiangluyu.xyz/2019/01/01/%E4%B8%8D%E9%97%AE%E5%BD%92%E6%9C%9F%E6%9D%A5%E8%B7%AF/"/>
    <id>https://www.jiangluyu.xyz/2019/01/01/不问归期来路/</id>
    <published>2018-12-31T23:12:27.000Z</published>
    <updated>2021-08-16T18:16:27.721Z</updated>
    
    <content type="html"><![CDATA[<p>这条路上的人有很多，在2018这段收费公路上，说真的，还挺挤的（笑）。</p><p>我想了好久，这一路我怎么过来的，遇到了哪些人，经历了哪些事。</p><p>全部写下来吧。</p><a id="more"></a><h5 id="2017-12-31"><a href="#2017-12-31" class="headerlink" title="2017.12.31"></a><strong>2017.12.31</strong></h5><p>已经忘了写了什么又删了什么。</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200303015254.png" alt=""></p><h5 id="2018-01-01"><a href="#2018-01-01" class="headerlink" title="2018.01.01"></a>2018.01.01</h5><p> 去年的年终总结嗷。</p><blockquote><p>我的2017，疯狂而又迷人。<br>疯狂而安静的高考倒计时，逃晚自习躺操场上看星星，也只有那会儿做得出。“幽暗的萤绿色灯光下，每个人的背影都漾在周边的空气里，或散步，或疾走，或嬉戏，或追闹，放在这片草坪上，零落得像幅静止的画。”这是我的草坪，它留在那儿了。<br>“我有故事，你有酒吗?”<br>“抱歉，我的故事那么无聊，没劲。”<br>高考，以前很看重，可能以后也很看重，至少现在我觉得没那么重要了。它只会决定你的下一步往哪儿走，可是无论你往哪儿走，都会认识一堆槽点满满却又可爱至极的人。<br>俗点，跟史主任说得一样，“只是决定你以后在哪个城市打英雄联盟”，过了那么久，只是英雄联盟变成了吃鸡王者了吧。<br>想得最多的，还怕是那个高考前阵的夜话闲聊和传奇的宜兴爱情故事。<br>六月，考场上潇洒走一回，和想的一样，真的“洒”了一点点，但其实，就像用杯子运水，除非下雨天，否则即使手再稳，也会失去些，蒸发什么的，总是存在的。<br>何况我手也没那么稳。<br>第一首想唱的歌，&lt;成都&gt;，没成想真的来了成都，火锅冒菜串串川菜的天堂，可惜傻鸡没来@驴蛋蛋。一水儿的来四川的兄弟，只剩下一个@连长。<br>诶，啥时候寄点特产来不？@驴蛋蛋<br>想你早日脱单，在线等，挺急的。<br>@许致远 我可能欠自己一份真正的疯狂，至少我现在不后悔。祝你安好，早日脱单。<br>这里得留给帅杨 @骚羊…… 的未成行的和桥烧烤和带劲的重庆小面。<br>@周成瑜 阿华还在田里努力耕作。<br>@徐雨涵 山上新鲜采摘的熊猫。<br>@冯羽韬 骚还是你骚。<br>@朱刚宪 47474747!<br>北边的，南边的，我终将从你们的轨迹中渐渐淡去。我希望那一刻哪怕我糊涂了，我们之间也比陌生人多一层回忆的纸。<br>鸟蒋，蒋汤姆，大炮，懒&lt;菜?傻?-.-&gt;猫，蒋医师，他们都在原地，不会动了，但我会一直带着他们走，直到我走不动了为止。<br>七月上午学车，下午学吉他，最长最浪的暑假没浪起来，单纯充实。吃了贼多各种酒店的谢师宴，感觉神奇，好吧多到不想吃了。<br>@吴好猛哦 八月初疯狂的两人第一次出国自由行，语言不通，眼里全是天书，却那么有趣。因为交通问题去到岚山没坐小火车也没有漂流;在奈良喂鹿，衣服裤子被鹿咬得湿湿的;心斋桥为了买东西，暴走近四万步，穿梭人流，崩溃得不行;又累又饿的朝日生啤+大阪烧，爽;环球影城奇幻的项目和瓢泼的大雨毫不冲突;因为行李受限而穿了n件衣服n条裤子上飞机……遇见了有趣的人有趣的事，还是很好玩呀(｡ì_í｡)<br>田子坊，南京路，科技馆，迪士尼，还记得小时候呆的魔都，没怎么变，迪士尼的人数是真的骚了呀……佛系，佛系。<br>凌晨出发来成都，和爸妈在附近吃了第一顿火锅，那滋味已经忘了，可能比现在的，要美一些。<br>哦对，尼玛全聚德呢？@驴蛋蛋<br>最后又回来了啊:报道，入学，相识，面试，学习……期末。<br>你好，我的2018。</p></blockquote><h5 id="2018-02"><a href="#2018-02" class="headerlink" title="2018.02"></a>2018.02</h5><p>放假回家<del>三件事</del> 两件事：<del>学Java</del>、TOEFL、宣传部作业（海报和手绘视频~）</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200303015255.png" alt=""></p><p>视频：<a href="https://www.bilibili.com/video/av20413559">https://www.bilibili.com/video/av20413559</a></p><h5 id="2018-03-01"><a href="#2018-03-01" class="headerlink" title="2018.03.01"></a>2018.03.01</h5><p>做了一个奇怪的梦。</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200303015238.png" alt=""></p><h5 id="2018-03"><a href="#2018-03" class="headerlink" title="2018.03"></a>2018.03</h5><p>为了看牙，来来回回上海-成都飞了两三次。</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200303015239.png" alt=""></p><h5 id="2018-03-1"><a href="#2018-03-1" class="headerlink" title="2018.03"></a>2018.03</h5><p>这学期周三半学期满课来着…</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200303015240.png" alt=""></p><h5 id="2018-04-15"><a href="#2018-04-15" class="headerlink" title="2018.04.15"></a>2018.04.15</h5><p>立了一个flag，好的，倒了，今年会加油的哈哈哈哈哈。</p><p>有时候直接发公众号了来着。</p><p>链接：<a href="https://www.jiangluyu.com">https://www.jiangluyu.com</a></p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200303015241.png" alt=""></p><h5 id="2018-05-12"><a href="#2018-05-12" class="headerlink" title="2018.05.12"></a>2018.05.12</h5><p>复联上映，过了几天去看了，死了很多人。</p><h5 id="2018-05-17"><a href="#2018-05-17" class="headerlink" title="2018.05.17"></a>2018.05.17</h5><p>昨天夜里江安雷暴，窗边的我并没有醒。</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200303015244.png" alt=""></p><h5 id="2018-05-24"><a href="#2018-05-24" class="headerlink" title="2018.05.24"></a>2018.05.24</h5><p>这事我要记住的hhh</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200303015243.png" alt=""></p><h5 id="2018-05-28"><a href="#2018-05-28" class="headerlink" title="2018.05.28"></a>2018.05.28</h5><p>不知道@连长你记住没有，我帮你回忆回忆hhh</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200303015242.png" alt=""></p><h5 id="2018-06"><a href="#2018-06" class="headerlink" title="2018.06"></a>2018.06</h5><p>不管是上课还是考试月今年都有看世界杯嗷。</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200303015245.png" alt=""></p><h5 id="2018-06-28"><a href="#2018-06-28" class="headerlink" title="2018.06.28"></a>2018.06.28</h5><p>水漫三八广场</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200303015246.png" alt=""></p><h5 id="2018-07"><a href="#2018-07" class="headerlink" title="2018.07"></a>2018.07</h5><p>没想到军训当了标兵。</p><p>阿飞走的时候说：“走起，川大的兄弟，未来的精英们，好好学习，相逢就是缘分。”</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200303015247.png" alt=""></p><h5 id="2018-08-22"><a href="#2018-08-22" class="headerlink" title="2018.08.22"></a>2018.08.22</h5><p>六级没到600（591），90免修失败</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200303015248.png" alt=""></p><h5 id="2018-09-14"><a href="#2018-09-14" class="headerlink" title="2018.09.14"></a>2018.09.14</h5><p>学生会宣讲效果正式破产</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200303015249.png" alt=""></p><h5 id="2018-10-04"><a href="#2018-10-04" class="headerlink" title="2018.10.04"></a>2018.10.04</h5><p>第一次参加游戏线下活动</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200303015251.png" alt=""></p><h5 id="2018-11-25"><a href="#2018-11-25" class="headerlink" title="2018.11.25"></a>2018.11.25</h5><p>正式加入飞扬（拜师了）</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200303015250.png" alt=""></p><h5 id="2018-11-30"><a href="#2018-11-30" class="headerlink" title="2018.11.30"></a>2018.11.30</h5><p>？</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200303015252.png" alt=""></p><h5 id="2018-12-09"><a href="#2018-12-09" class="headerlink" title="2018.12.09"></a>2018.12.09</h5><p>迎新晚会结束了（老父亲般欣慰）</p><p><img src="https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200303015256.png" alt=""></p><hr><p>还有很多很多啊，上面的只是空间整理的。</p><p>比如换掉了用了一年半一直很喜欢的签名：一棵草，也会为了春天不遗余力。</p><p>可能比起上一段路，这一段没有那么冒险刺激，没有那么诗情画意，更多的是躲在幽暗中努力，和朋友们一起患难。这一年睡得不多，无论是从寒假回家开始，还是在学校肝视频，肝项目，肝活动，再加上一些习惯性晚睡，有时候丧，有时候暖。现在想想度过漫漫长夜一定不容易吧，睡觉一定是最好的对策。</p><p>生活不易，念且维坚。很感谢你们，这一段路收到了很多惊喜和温暖，还有时不时的交流与吐槽，这一路给了我很重要的力量，黄金日子里，愿友谊常在。路是自己选的，很早的时候就选了，很幸运能够遇到你们，都是可以独舞的灵魂。</p><p>今年刷了很多电影，顺便整理了一下，做个参考和留念。【附在后面】</p><p>眼看到了2019年了，希望今年拿下期末，拿下TOEFL，KO项目，KO论文，头发变多，继续单身，找到更多的动力，认识更多有趣的灵魂。嗯，剩下的我还没想好。2019应该有2019自己的喜悦与悲伤留给我吧，挺期待的。（flag可别倒啊！）</p><p>今年跨年和家乡来的小伙伴们过了，很冷很难忘，真的在成都的街头走一走，还走了一年（笑）。</p><p>说来今年成都下雪了，但是江安很小很短，没有积过雪。</p><p>窗外无雪，却念雪上人。</p><hr><p>附：</p><p>弱点                                                       ※※※※※※</p><p>美好的意外                                           ※</p><p>火锅英雄                              ※</p><p>全民情敌                              ※※※</p><p>飞行家                                  ※※※※</p><p>127小时                                                ※※※ </p><p>白日梦想家                                           ※※※※※※</p><p>真爱至上                                               ※※※※※※</p><p>彗星来的那一夜                                    ※※※※</p><p>大空头                                                    ※※※※</p><p>我是谁：没有绝对安全的系统              ※※※</p><p>轻松自由                                                 ※※※※※※</p><p>孤儿怨                                                     /</p><p>放牛班的春天                                          ※※※※※※</p><p>监守自盗                                                  ※※</p><p>返老还童                                                  ※※※※※※</p><p>点球成金                                                  ※※※※※※</p><p>死亡医生                                                  ※※※※</p><p>大而不倒                                                  ※※※※※※</p><p>社交网络                                                  ※※※※※</p><p>成事在人                                                  ※※※※</p><p>无双                                                         ※※※</p><p>传奇的诞生                                              ※※※※</p><p>你好，之华                                              ※※※※</p><p>胖子行动队                                              ※※</p><p>月球                                                          ※※※※</p><p>禁闭岛                                                      ※※※※※※</p><p>私人订制                                                  ※※※</p><p>甲方乙方                                                  ※※※</p><p>让子弹飞                                                  ※※※※※</p><p>一步之遥                                                  ?</p><p>邪不压正                                                  ※※※※</p><p>看不见的客人                                          ※※※※※※</p><p>三块广告牌                                              ※※※※※※</p><p>玉子爱情故事                                          ※※※</p><p>达拉斯买家俱乐部                                   ※※※※※※</p><p>最佳出价                                                   ※※※※</p><p>再次出发                                                   ※※※※※※</p><p>惊天魔盗团2                                             ※※</p><p>惊天魔盗团                                               ※※※※</p><p>的士速递                                                   ※※※※</p><p>爱情公寓                                                   ?</p><p>超体                                                           ※※※※</p><p>闻香识女人                                               ※※※※※※</p><p>神奇动物在哪里                                       ※※※※</p><p>奇异博士                                                   ※※※※</p><p>美丽心灵                                                   ※※※※※※</p><p>心花路放                                                   ※※</p><p>幸福终点站                                                 /</p><p>星运里的错                                               ※※※※※</p><p>头号玩家                                                   ※※※※※※</p><p>闪灵                                                           ※※※※</p><p>泰迪熊2                                                     ※※※</p><p>姚明年                                                       ※※※</p><p>钢琴家                                                       ※※※※※</p><p>火星救援                                                   ※※※※※※</p><p>解救吾先生                                               ※※※※</p><p>昨日青空                                                   ※※※</p><p>星际穿越                                                   ※※※※※※</p><p>至暗时刻                                                   ※※※※※※</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这条路上的人有很多，在2018这段收费公路上，说真的，还挺挤的（笑）。&lt;/p&gt;
&lt;p&gt;我想了好久，这一路我怎么过来的，遇到了哪些人，经历了哪些事。&lt;/p&gt;
&lt;p&gt;全部写下来吧。&lt;/p&gt;
    
    </summary>
    
      <category term="年终总结" scheme="https://www.jiangluyu.xyz/categories/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="https://www.jiangluyu.xyz/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>

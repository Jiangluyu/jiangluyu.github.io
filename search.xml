<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[剑指Offer]]></title>
    <url>%2F2022%2F02%2F21%2F%E5%89%91%E6%8C%87Offer%2F</url>
    <content type="text"><![CDATA[栈&amp;队列E09 用两个队列实现栈创建栈A和栈B，栈A负责push，栈B负责接收栈A所有元素后pop。 E30 包含min函数的栈创建一个辅助栈，每次主栈push/pop操作时同时push/pop当前最小值。 1# include &lt;algorithm&gt; // std::min() 链表E06 从尾到头打印链表用vector遍历，再reverse。 1reverse(vector.begin(), vector.end()) E24 反转链表遍历： ​ 创建prev，curr，temp三个结点，初始prev=NULL，curr=head，temp=NULL。 用temp保存curr-&gt;next，令curr-&gt;next=prev，prev=curr，curr=temp，直到curr为NULL。 递归： ​ 中间处理：类似1-&gt;2-&gt;3 =&gt; 1-&gt;2-&gt;3-&gt;2 =&gt; 1-&gt;2&lt;-3 ​ 终结条件：head == NULL || head -&gt; next == NULL ​ 处理步骤：head -&gt; next -&gt; next = head; ​ head -&gt; next = NULL M35 复杂链表的复制迭代+节点拆分： ​ A-&gt;A’-&gt;B-&gt;B’-&gt;C-&gt;C’，遍历三次 第一次遍历：从A-&gt;B-&gt;C形成A-&gt;A’-&gt;B-&gt;B’-&gt;C-&gt;C’ 第二次遍历：使得A’, B’, C’的random指向对应的node 第三次遍历：剥离A’-&gt;B’-&gt;C’，恢复原来的A-&gt;B-&gt;C 字符串E05 替换空格创建新数组： 时间空间均为O(N) 原地修改： （C++ string可变） 统计空格数 -&gt; 扩展string长度 str.resize() -&gt; 倒序插入，left指向原字符串末尾，right指向新字符串末尾，如果str[left] == ‘ ‘，str[right~rigfht-2]替换为%20，right-=2，否则复制str[left]内容 空间O(1)，时间O(N) E58-2 左旋转字符串允许额外空间： return (s+s).substr(n, s.size()); 不允许额外空间： 三次旋转：整体旋转+前半段n旋转+后半段旋转，reverse() 查找算法E03 数组中的重复数字哈希表： unordered_map记录 原地交换： 1~n-1的数字，意味着一对多的映射。 遍历，当nums[i] == i时，递增； 如果nums[nums[i]] = i，即两个数字相等，则break， 否则交换nums[i]和nums[nums[i]]，重新比较nums[i]与i是否满足继续向后的条件 E53-1 在排序数组中查找数字看到排序数组一般想到二分： 两次二分法：第一次找左边界，第二次找右边界 这里可以优化：找target&amp;target-1（是否在数组里不重要），返回right index，结果为bs(target) - bs(target - 1 ) 123456789101112131415161718int binary_search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0; int right = nums.size() - 1; // 想不清楚可以举个简单例子画图 // 注意'/'向下取整 while (left &lt;= right) &#123; int mid = (left + right) / 2; if (nums[mid] == target) &#123; return mid; &#125; else if (nums[mid] &gt; target) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return -1; // 没找到&#125; E53-2 0~n-1中缺失的数字排序数组首先考虑二分 nums[mid] == mid时，说明缺失值在[mid + 1, right] nums[mid] &gt; mid时，说明缺失值在[left, mid] 最终返回right + 1即可，本题也可以返回left M04 二维数组中的查找暴力： 面试官：“今天就到这里吧:monkey:” “二分”： 一开始想到按行二分，后来看到更好的类似二维二分的方法 由于矩阵中行列的递增性，可以从右上角开始搜索，若M[row][col] &gt; target，则col—；若M[row][col] &lt; target，则row++ 需要注意的是，有个奇怪的边界输入：[] E11 旋转数组的最小数字包含两个非降序，同样可以考虑二分法 如果mid处值&gt;最右端点处，说明最小值点在mid右边 如果mid处值&lt;最右端点处，说明最小值点在mid左边，此时mid处也有可能是最小值，所以不能right = mid - 1，而要right=mid 如果mid处值=最右端点处，有重复值，说明最右端点可以忽略 返回时此时有可能mid处 = right处，导致right—，而最小值在mid处，所以return numbers[left] E50 第一个只出现一次的字符第一感觉：标记法： unordered_map 当字符串很长的时候： unordered_map vector\记录插入map中的顺序 队列： 用队列维护第一个只出现一次的元素 函数 说明 front() 返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。 back() 返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。 push(const T&amp; obj) 在 queue 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 push_back() 来完成的。 push(T&amp;&amp; obj) 以移动的方式在 queue 的尾部添加元素。这是通过调用底层容器的具有右值引用参数的成员函数 push_back() 来完成的。 pop() 删除 queue 中的第一个元素。 size() 返回 queue 中元素的个数。 empty() 如果 queue 中没有元素的话，返回 true。 emplace() 用传给 emplace() 的参数调用 T 的构造函数，在 queue 的尾部生成对象。 搜索与回溯算法M32-1 从上到下打印二叉树按题意即为广度优先搜索，BFS优先考虑队列： 题目不难，这里讲讲queue和deque的区别： queue双端都能访问，deque（double-ended queue）亦然，deque的特点是两端都能插入、弹出，而queue只能在首端弹出、末端插入，因而deque在api上区分了push_front(), push_back(), pop_front(), pop_back() E32-2 从上到下打印二叉树II和M32-1的区别在于要将每一行对应数组的一行 多加个标号： queue]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习笔记]]></title>
    <url>%2F2020%2F03%2F20%2FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[人生中第一次面试，体验难忘，收获也良多。其中一个收获便是学校要求与企业要求的巨大的不对称性，春招秋招是拉当前最符合企业要求的人上岸的。积累了第一次经验，下次努力。 参考课程（站点-组织-课程名-授课教师）： 中国大学MOOC-北京邮电大学-Linux开发环境应用-蒋砚军/高占春/周安福 Coursera- 1. 系统状态查看1.1 Linux的字符终端 终端Terminal UNIX/Linux是多用户系统 主机连接多台字符终端 字符终端作为交互式输入输出设备 终端构成 键盘 显示器 RS232串行通信接口 字符终端历史 英文打字机（typewriter） 电传打字机（teletypewriter，简写tty） 字符终端，以屏幕代替卷纸打印机（仍称作tty设备） 主机与终端的链接 串口卡引出多个RS232串口 每个RS232接口通过电缆（$\geq3%$芯）连接一台终端 RS232电缆早期长度限制10米，现在可达百米 终端与主机的功能分工 终端：主机的输入输出设备 终端通过电缆将用户的按键信息送到主机，把主机发送过来的信息在屏幕上显示 主机：程序和数据的存储及处理 数据及程序存放在主机的硬盘上，程序的运行也都由主机内的CPU占用主机内存来完成 行律（line discipline）与驱动程序 驱动程序 驱动不同硬件 与行律模块的接口：上行和下行字符流 行律的作用 一行内字符的缓冲、回显与编辑，直到按下回车 数据加工，如将\n转化为\r\n 将Ctrl+C字符转化为中止进程运行的信号（signal） 主机与终端之间的通信过程 运行程序 1234567891011#include &lt;stdio.h&gt;int main(void)&#123; int n; printf("Input N: "); scanf("%d", &amp;n); printf("N * N = %d\n", n * n); printf("Bye!\n");&#125; 终端按键五次 1 7 Backspace 6 Enter Note: 回显退格的方式为，先用\b将光标往前移一格，再输入空格，再用\b将光标往前移一格。 行律功能的调整 必要性：输入口令时不希望回显；不希望等到回车才将缓冲区内信息传递等 调整方法 程序内编程 相关命令stty： 12stty erase ^H # ^H即对应ASCII码8，即Backspace，因为有的终端不支持Backspace按键stty -a # 将行律中的所有信息状态打印出来 终端转义序列 转义字符 Esc：ASCII码1B（dec: 27, Oct: 033） Note：不支持输入时可以用\033 主机发往终端方向数据中的转义序列的功能 控制光标位置、字符颜色、字符大小等 选择终端的字符集 控制终端上的打印机、刷卡器、磁条器、密码键盘 举例 Esc[2J 功能：清除屏幕 Esc[8A 功能：光标上移8行 Esc[16;8H 功能：光标上移16行8列 Esc[1;31m 功能：红色字符 终端类型 定义一组转义序列及其对应操作 例如：ANSI，VT100，VT220等 仿真终端和虚拟终端 仿真终端 PC机RS232串口，运行仿真软件模拟真正终端设备的功能，如CrossTalk，Win中的超级终端 仿真内容包括实现转义码序列功能 虚拟终端 终端与主机之间的通信由串口线变为TCP连接，双向传递字节流 主机与PC通过网络相连，Client运行telnet，Server运行telnetd 安全终端，在TCP连接上加密和压缩数据，如SecureCRT与Putty 1.2 用户登录和联机手册的查阅 普通用户和超级用户 root用户 不受权限制约，可随意修改和删除文件 误删文件可能带来严重后果 创建新用户 由root用户创建（命令：useradd），用户信息存放在/etc/passwd文件中包括用户名和用户ID，以及Home目录，登录shell（一般为bash，也可以选其他shell，或应用程序） 使用Linux 登录成功后出现shell提示符 $表示Bourne Shell系列 表示当前用户为root 对字母大小写敏感 基本Linux命令 man 查阅手册 date 日期与时间 cal 日历 bc 计算器 passwd 修改口令 man：查阅联机手册（manual前三个字母） 手册内容 命令的说明书 系统调用的使用手册 C语言和其他语言的库函数手册 系统配置文件格式 命令 分页器：q-退出，space-下一页，上下箭头-上移下移 用法 man name man section name 章节编号：1-命令，2-系统调用，3-库函数，5-配置文件 man -k regexp 列出关键字（keyword）与正则表达式regexp匹配的手册项目录 内容 基本功能和语法 对于C语言的函数调用，列出头文件及链接函数库 功能说明 SEE ALSO：有关的其他项目的名字和章节号 1.3 时间、计算器和口令维护 date：读取系统日期和时间 用法： date 读取系统日期和时间，如Wed Nov 7 21:09:16 CST 2018 根据需要定制输出格式 date “+%Y-%m-%d %H:%M:%S Day %j” 2018-11-07 21:09:54 Day 311 date “+%s” 1541596457 311指今天是今年的第311天 格式控制：第一个字符必须为+号，%Y-年，%m-月，%d-日，%H-时，%M-分，%S-秒 %s-标坐标（从UTC1970开始），常用于计算时间间隔 通过NTP协议（Network Time Protocol）校对系统时间：命令ntpdate ntpdate 0.pool.ntp.org（设置时间，需要root用户） ntpdate -q 0.pool.ntp.org（query，查询时间，普通用户即可） cal：打印日历（calendar前三个字母） 用法 cal cal year cal month year 举例 cal 功能：打印当前月份的日历 cal 2020 功能：打印2020年的日历 cal 10 2019 功能：打印2019年10月份的日历 cal 12 功能：打印公元12年的日历 bc：计算器（basic calculator缩写） 功能强大 基本计算器功能 支持变量a~z，函数，条件，循环等编程功能 进行任意精度的计算 精度 缺省精度 bc 缺省精度为1 bc -l缺省精度为小数点后20位 通过scale自行决定精度 scale=10000 s(1.0) 即求小数点后10000位精度的sin(1.0)的值 passwd：更换口令（password缩写） 普通用户 使用passwd命令修改自己的口令，须先验证原口令 root 直接修改新口令 可强制修改其他用户口令，但无法读取其他用户口令 例如：passwd liu 将liu的口令强制设置为新口令 口令的设置与验证 口令的保存：不存明码 验证方法：验证生成序列+输入的口令通过哈希算法后是否与存储的哈希值相同 1.4 了解系统状态 几个了解系统状态的命令 who：确定谁在系统中 uptime：了解系统启动时间及忙碌程度 top：列出资源占用排名靠前的进程 free：了解内存使用情况 vmstat：了解系统负载情况 who：确定谁在系统中 who：列出当前登入系统的用户 | 用户名 | 终端设备的设备文件名 | 登录时间 || ——— | —————————— | —————- || wujian | tty00 | Jul 5 14:49 || sun | tty01 | Jul 5 11:31 | 设备文件一般存放于/dev下 tty：打印当前终端的设备文件名 who am i：列出当前终端上的登录用户信息 whoami：仅列出当前终端上的登录用户名 uptime：已开机时间 uptime：系统运行时间，当前登入用户数，近期（1min，5min，15min）内CPU负载（平均调度队列长度） top：列出资源占用排名靠前的进程 top 第一行，任务队列信息，同uptime命令的执行结果 第二行，Tasks进程 第三行，CPU状态信息 us（user space）- 用户空间占用CPU的百分比。 sy（sysctl）-内核空间占用CPU的百分比。 ni-改变过优先级的进程占用CPU的百分比 id（idolt）-空闲CPU百分比 wa（wait）-IO等待占用CPU的百分比 hi（Hardware Interrupts）-硬中断占用CPU的百分比 si（Software Interrupts）-软中断占用CPU的百分比 第四行，内存状态 第五行，swap交换分区信息 第七行以下：各进程的状态监控 PID-进程id USER-用户 PR（priority）-进程优先级 NI（nice）-负-&gt;正，高优先级-&gt;低优先级 VIRT（virtual）-进程逻辑地址空间大小 RES（Resident）-驻留内存数即占用物理内存数 SHR（share）-与其他进程共享内存数 %CPU-占用CPU百分比 %MEM-占用内存百分比 TIME+-占用的CPU时间 COMMAND-进程名称（命令名/命令行） ps（process status）：查询进程状态 选项 空：只列出在当前终端上启动的进程（PID，TTY，TIME，COMMAND） -e：列出系统中所有进程 -f：以full格式列出每一个进程 -l：以long格式列出每一个进程 进程属性 UID（user id） PID（process id） PPID（parent process id） C（CPU）：最近一段时间（秒级别）CPU占用情况 STIME：启动时间 SZ：进程逻辑内存大小 TTY COMMAND WCHAN（wait channel）：进程在内核的何处睡眠 TIME：累计执行时间（占用CPU的时间） PRI（priority） S（status）：Sleep，Run，Zombie（结束后暂时还未关闭） free：了解内存使用情况 free 内存总量1.8GB，空闲69MB Linux为提高效率，利用程序暂时不用的内存，缓冲读写过的磁盘信息，减少I/O时间，当前有313MB的buffer/cache 不计buffer/cache，系统有实际可利用资源179MB 打印了磁盘Swap区的使用情况 vmstat：了解系统负载 vmstat procs：r-待运行的进程数，b-处在非中断睡眠状态的进程数 memory：空闲的内存，buffer/cache用做缓存的内存数 swap：磁盘/内存的交换页数量（单位：KB/s） IO：块设备的I/O块数（单位：块/s） system：in（interrupt）-每秒的硬件中断数，包括时钟中断，cs（context switch）-每秒的环境切换次数 CPU：CPU的总使用率，us（user），sy（system），id（idle），wa（wait for disk I/O） 1.5 复习题 C语言编写的应用程序，通过printf打印一个换行符\n，但在终端上执行的是回车加换行\r\n，把换行符替换为回车换行是由下面哪个软件模块完成的？ Linux内核中的行律模块 Linux超级用户的用户名为： root 哪个命令可以获得某进程占用的逻辑内存大小？ top 哪个命令可以了解目前系统CPU的空闲情况？ uptime 传统的终端与Linux主机之间传输的是字节流。（true or false) true 终端转义序列的意义在于终端收到某一特定字符序列后执行一些约定好的控制功能，而不是把这些字符显示在显示器上。（true or false) true 在终端按下Ctrl-C按键一般会导致一个死循环程序中止运行，这是因为按下Ctrl-C之后终端并不向Linux输送字符，而是通过RS232接口的一条特殊信号线通知Linux主机，将进程终止。（true or false) false（通过行律） Linux命令不区分字母的大小写，一般习惯用小写字母。（true or false) false（Linux区分大小写） 直接执行bc命令，后面不带任何选项，除法计算时保留小数点后20个有效数字。（true or false) false（默认精度为1） Linux中超级用户的权限很大，可以读取普通用户的口令值。（true or false) false（只能强制修改，不能读取） 2. 文本文件的处理2.1 文本文件及处理工具 Linux中的文本信息 文本文件 C语言、Java语言等的编程文件 文本格式的数据文件 文本格式的文字信息 程序输出 系统配置信息 /etc下的配置文件（类似win下的注册表） 文本型网络协议 大部分传输层以上协议 会话层协议：HTTP，POP3，SMTP，IMAP 表示层协议：HTML，XML，MIME 文本文件处理的命令 Linux提供大量 的文本文件处理的命令 命令自带的选项 进程的标准输入/输出 进程的基本概念 进程和程序 程序：存储在计算机上的代码文件 进程：经过编译后正在运行的程序 进程的输入输出 stdin，默认键盘 stdout，默认屏幕 重定向与管道 重定向机制 输出重定向 如：ls -l &gt; filelist.txt Note：本身ls -l会将信息显示在屏幕上，上述命令将其写入filelist.txt文件中，不会再打印在屏幕上 输入重定向 如：sort &lt; filelist.txt Note：sort默认从stdin中获取输入，上述命令使sort从filelist.txt中获取输入 重定向机制与管道机制的重要性 文本文件处理命令的特点 特点 不指定对象时，默认从stdin获得数据 制定对象时，从对象中获得数据 多数命令可以指定多个文件 处理结果将在stdout显示 考虑的因素 标准输入/标准输出 shell的文件通配符（可以同时处理多个对象） 输入输出重定向 管道 灵活性：工具命令的组合 Linux倾向于提供独立的多个精巧的工具命令，数据格式为文本信息 鼓励使用重定向或管道机制将多个工具命令组合，提供更灵活的功能 应用系统设计时，也应该考虑到这些特点 如数据库显示，直接输出多列文本，考虑到各种工具软件的使用 2.2.1 读取文件内容 文本文件读取与处理的几个命令 more/less：逐屏显示文件 cat（concatenate）/od（octal dump）：列出文件内容 head/tail：列出文件的头部/尾部 tee：三通 wc（word count）：字计数 sort：对文件内容排序 tr（translate）：翻译字符 uniq（unique）：筛选重复行 more/less：逐屏显示文件 历史 more：BSD UNIX开发 less：Linux广泛使用 使用方法： more shudu.c 指定单个文件 more *.[ch] 指定多个文件 ls -l| more 指定0个文件（因为从管道中获取输入） less shudu.c more more 满屏后，显示—more—或—more—(15%)，more命令 空格：显示下一屏 回车：下移一行 q（quit） /pattern：搜索指定pattern的字符串，正则表达式 /：继续查找指定模式的字符串 h（help） ^L：屏幕刷新 less less：来源为less is more 回退浏览功能更强：上下箭头键、J、K、PgUp等键 有些Unix系统不提供less命令 cat/od：列出文件内容 命名与功能 cat：concatenate：串结，文本格式打印（-n：显示行号） od：octal dump：逐字节打印（-c，-t c，-t x1，-t d1，-t u1） 举例 cat tryl.c cat -n shudu.c cat tryl.c tryx.c try.h cat &gt; try 命令行参数为0个，直接从stdin获取数据，知道^D，将内容写入try文件中 cat tryl.c try2.c try.h &gt; trysrc cat makefile *.[ch] &gt; src od -t x1 x.dat 以十六进制打印文件x.dat的各字节 od -t x1 x.dat | more od -c /bin/bash 逐字符打印文件，遇到不可打印字符则打印编码 echo abcdABCD | od -t x1 十六进制显示abcdABCD的ASCII码 head/tail：显示文件的头部和尾部 默认10行，-n可以指定行数 head -n 15 ab.c head -n 23 a.c b.c c.c | more tail -n 40 a.txt head -n -20 msg.c 除去尾部20行，其余均显示 tail -n +20 msg.c 除去开头20行，其余均显示 tail -f debug.txt 实时打印文件尾部被追加的内容 组合运用如：netstat -s -p tcp | head, ls -s | sort | head -n 20 2.2.2 文本数据的处理 tee：三通 功能 将stdin得到的数据抄送stdout，同时存入文件 举例 ./myap | tee myap.log wc(word count)：字计数 功能 列出文件的行数，单词数，字符数 当文件数$\gt1$时，最后还列出一个合计 常用选项-l，只列出行数 举例 wc sum.c wc x.c makefile start.sh wc -l *.c makefile start.sh ps -ef | wc -l ps -ef | grep liang | wc -l Note：grep为正则表达式或查找字符串，上述命令即在所有full格式的进程信息中查找包含liang字符串的进程数（即行数） who | wc -l sort：对文件内容排序 sort选项 -n（numeric）：对于数字按照算术值大小排序，而非字符串比较规则排序 Note：字符串规则排序时，67$\gt$123 可以选择行中某一部分作为排序关键字 选择升序或降序 字符串比较时对字母是否区分大小写 内排序，外排序等算法的选择 举例 sort telno &gt; telno1 ls -s | sort | tail -n 10 ls -s | sort -n | tail -10 Note：tail -10与tail -n 10等价，即显示倒数10行 tr（translate）：翻译字符 用法 tr string1 string2 把stdin拷贝到stdout，字符串1中出现的字符替换为字符串2中的对应字符 举例 cat linuxlearn.txt | tr u U cat linuxlearn.txt | tr ‘[a-z]’ ‘[A-Z]’ cat file1 | tr ‘\012’ % 将换行符换为% uniq（unique）：筛选文件中的重复行 用法 uniq options uniq options inputfile uniq options inputfile outputfile 重复的行 重复的行定义为紧邻两行的内容相同 选项 空：打印没有重复的行与有重复的行（但仅打印一次） -u（unique）：只保留没有重复的行 -d（duplicated）：只保留有重复的行，但仅打印一次 -c（count）：计数同样的行出现几次 2.3 复习题 使用less命令逐屏显示文本文件时，使得显示内容上滚一行而不是滚动一屏，应按下哪个键？ 回车/↓ Linux中用来实现计数功能，比如：统计系统有多少个登录用户，实现计数功能的命令是： wc -l Linux使用|符号连接两个命令使用管道机制，设计管道机制的目的是： 将前一个命令的输出作为下个命令的输入，提供更灵活的功能 uniq命令可以通过它的选项，选择打印所有只出现一次的行，或者打印出现不只一次的行，或者两种都选。但无论哪种情况，重复出现的行最多只能打印一次。（true or false） true 一个应用程序的C语言源程序通过printf语句在标准输出输出信息，运行时只要使用输出重定向机制，不需要修改原先的程序加入文件操作的代码，就可以把输出结果存入指定名字的文件。（true or false） true less命令时more命令的一个简化版本，精简后功能比more弱，但更节约内存和CPU。（true or false） false（less和more是两种实现不同的命令） tail命令的-f选项可以让tail命令持续运行下去，持续地将它操作的文本文件新增的数据显示出来。如果这个文本文件被其他进程随时间推移断断续续追加几行，tail也会断断续续地输出这些新增的内容。（true or false） true 可以为tee命令提供一个文件名abc.log，例如：xyz | tee abc.log 那么，通过管道的方式可以把前面xyz命令的输出结果在当前终端上显示的同时也存入磁盘文件abc.log，可供事后查阅。如果以某用户正在使用的终端的设备文件名(如/dev/pts/2)代替文件名abc.log，那么，这个xyz命令执行时的输出就会同时在两个终端上实时显示。就算是把前面的xyz命令换成vi也是完全可能的，也就是说完全可能在第二个终端上实时看到第一个终端上的编辑画面。（true or false） true 不带任何选项的uniq命令消除数据中重复的行。一旦某一行出现过，uniq会记录下来，以后无论这一行在以后什么地方再次出现，输出时都会被忽略，保证数据的唯一行。（true or false） false（重复的行的定义仅为相邻的两行是否相同） 信息由一个个字节组成，tr命令处理这些信息时，可以将256种字节值中的任何一种取值“翻译”为另一个字节值，并且不限于可打印字符之间的转译，比如把换行符替换为斜线。（true or false） true]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>初学者</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[六道股票问题]]></title>
    <url>%2F2020%2F03%2F09%2F%E5%85%AD%E9%81%93%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[文章为转载，侵删，仅供自己收藏 [英文版][https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems][中文版翻译][https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/] 0 背景很多读者抱怨股票系列问题奇技淫巧太多，如果面试真的遇到这类问题，基本不会想到那些巧妙的办法，怎么办？所以本文拒绝奇技淫巧，而是稳扎稳打，只用一种通用方法解决所用问题，以不变应万变。 这篇文章用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 DP table，看一眼就明白了。 先随便抽出一道题，看看别人的解法： 1234567891011121314int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if(prices.empty()) return 0; int s1 = -prices[0]; int s2 = INT_MIN; int s3 = INT_MIN; int s4 = INT_MIN; for(int i = 1; i &lt; prices.size(); ++i) &#123; s1 = max(s1, -prices[i]); s2 = max(s2, s1 + prices[i]); s3 = max(s3, s2 - prices[i]); s4 = max(s4, s3 + prices[i]); &#125; return max(0, s4);&#125; 能看懂吧？会做了吗？不可能的，你看不懂，这才正常。就算你勉强看懂了，下一个问题你还是做不出来。为什么别人能写出这么诡异却又高效的解法呢？因为这类问题是有框架的，但是人家不会告诉你的，因为一旦告诉你，你五分钟就学会了，该算法题就不再神秘，变得不堪一击了。 本文就来告诉你这个框架，然后带着你一道一道秒杀。 这 6 道股票买卖问题是有共性的，我们通过对第四题（限制最大交易次数为 k）的分析一道一道解决。因为第四题是一个最泛化的形式，其他的问题都是这个形式的简化。 第一题是只进行一次交易，相当于 k = 1；第二题是不限交易次数，相当于 k = +infinity（正无穷）；第三题是只进行 2 次交易，相当于 k = 2；剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种，都很容易处理。 1 穷举框架首先，还是一样的思路：如何穷举？这里的穷举思路和上篇文章递归的思想不太一样。 递归其实是符合我们思考的逻辑的，一步步推进，遇到无法解决的就丢给递归，一不小心就做出来了，可读性还很好。缺点就是一旦出错，你也不容易找到错误出现的原因。比如上篇文章的递归解法，肯定还有计算冗余，但确实不容易找到。 而这里，我们不用递归思想进行穷举，而是利用「状态」进行穷举。我们具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。听起来抽象，你只要记住「状态」和「选择」两个词就行，下面实操一下就很容易明白了。 1234for 状态1 in 状态1的所有取值： for 状态2 in 状态2的所有取值： for ... dp[状态1][状态2][...] = 择优(选择1，选择2...) 比如说这个问题，每天都有三种「选择」：买入、卖出、无操作，我们用 buy, sell, rest 表示这三种选择。但问题是，并不是每天都可以任意选择这三种选择的，因为 sell 必须在 buy 之后，buy 必须在 sell 之后。那么 rest 操作还应该分两种状态，一种是 buy 之后的 rest（持有了股票），一种是 sell 之后的 rest（没有持有股票）。而且别忘了，我们还有交易次数 k 的限制，就是说你 buy 还只能在 k &gt; 0 的前提下操作。 很复杂对吧，不要怕，我们现在的目的只是穷举，你有再多的状态，老夫要做的就是一把梭全部列举出来。这个问题的「状态」有三个，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合： 123456789dp[i][k][0 or 1]0 &lt;= i &lt;= n-1, 1 &lt;= k &lt;= Kn 为天数，大 K 为最多交易数此问题共 n × K × 2 种状态，全部穷举就能搞定。for 0 &lt;= i &lt; n: for 1 &lt;= k &lt;= K: for s in &#123;0, 1&#125;: dp[i][k][s] = max(buy, sell, rest) 而且我们可以用自然语言描述出每一个状态的含义，比如说dp[3][2][1]的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如dp[2][3][0]的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。很容易理解，对吧？ 我们想求的最终答案是dp[n - 1][K][0]即最后一天，最多允许 K 次交易，最多获得多少利润。读者可能问为什么不是dp[n - 1][K][1]？因为[1]代表手上还持有股票，[0] 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。 记住如何解释「状态」，一旦你觉得哪里不好理解，把它翻译成自然语言就容易理解了。 2 状态转移框架现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。只看「持有状态」，可以画个状态转移图。 通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程： dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) max( 选择 rest , 选择 sell ) 解释：今天我没有持有股票，有两种可能：要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。 12dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) max(选择rest ，选择buy) 解释：今天我持有着股票，有两种可能：要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。 这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的。 现在，我们已经完成了动态规划中最困难的一步：状态转移方程。如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了。不过还差最后一点点，就是定义 base case，即最简单的情况。 dp[-1][k][0] = 0解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。dp[-1][k][1] = -infinity解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。dp[i][0][0] = 0解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。dp[i][0][1] = -infinity解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。把上面的状态转移方程总结一下： 1234567base case：dp[-1][k][0] = dp[i][0][0] = 0dp[-1][k][1] = dp[i][0][1] = -infinity状态转移方程：dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) 读者可能会问，这个数组索引是 -1 怎么编程表示出来呢，负无穷怎么表示呢？这都是细节问题，有很多方法实现。现在完整的框架已经完成，下面开始具体化。 3 秒杀题目3.1 k = 1直接套状态转移方程，根据 base case，可以做一些化简： 123dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) = max(dp[i-1][1][1], -prices[i]) 解释：k = 0 的 base case，所以dp[i-1][0][0] = 0。 现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。可以进行进一步化简去掉所有 k： 12dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])dp[i][1] = max(dp[i-1][1], -prices[i]) 直接写出代码： 1234567int n = prices.length;int[][] dp = new int[n][2];for (int i = 0; i &lt; n; i++) &#123; dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]); dp[i][1] = Math.max(dp[i-1][1], -prices[i]);&#125;return dp[n - 1][0]; 显然 i = 0 时dp[i-1]是不合法的。这是因为我们没有对 i 的 base case 进行处理。可以这样处理： 12345678910111213141516171819for (int i = 0; i &lt; n; i++) &#123; if (i - 1 == -1) &#123; dp[i][0] = 0; // 解释： // dp[i][0] // = max(dp[-1][0], dp[-1][1] + prices[i]) // = max(0, -infinity + prices[i]) = 0 dp[i][1] = -prices[i]; //解释： // dp[i][1] // = max(dp[-1][1], dp[-1][0] - prices[i]) // = max(-infinity, 0 - prices[i]) // = -prices[i] continue; &#125; dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]); dp[i][1] = Math.max(dp[i-1][1], -prices[i]);&#125;return dp[n-1][0]; 第一题就解决了，但是这样处理 base case 很麻烦，而且注意一下状态转移方程，新状态只和相邻的一个状态有关，其实不用整个 dp 数组，只需要一个变量储存相邻的那个状态就足够了，这样可以把空间复杂度降到 O(1): 12345678910111213// k == 1int maxProfit_k_1(int[] prices) &#123; int n = prices.length; // base case: dp[-1][0] = 0, dp[-1][1] = -infinity int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE; for (int i = 0; i &lt; n; i++) &#123; // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]); // dp[i][1] = max(dp[i-1][1], -prices[i]) dp_i_1 = Math.max(dp_i_1, -prices[i]); &#125; return dp_i_0;&#125; 两种方式都是一样的，不过这种编程方法简洁很多。但是如果没有前面状态转移方程的引导，是肯定看不懂的。后续的题目，我主要写这种空间复杂度 O(1) 的解法。 3.2 k = +infinity如果 k 为正无穷，那么就可以认为 k 和 k - 1 是一样的。可以这样改写框架： 123dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i]) 我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了： 12dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]) 直接翻译成代码： 12345678910int maxProfit_k_inf(int[] prices) &#123; int n = prices.length; int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE; for (int i = 0; i &lt; n; i++) &#123; int temp = dp_i_0; dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]); dp_i_1 = Math.max(dp_i_1, temp - prices[i]); &#125; return dp_i_0;&#125; 3.3 k = +infinity with cooldown每次 sell 之后要等一天才能继续交易。只要把这个特点融入上一题的状态转移方程即可： 12dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i]) 解释：第 i 天选择 buy 的时候，要从 i-2 的状态转移，而不是 i-1 。翻译成代码： 123456789101112int maxProfit_with_cool(int[] prices) &#123; int n = prices.length; int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE; int dp_pre_0 = 0; // 代表 dp[i-2][0] for (int i = 0; i &lt; n; i++) &#123; int temp = dp_i_0; dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]); dp_i_1 = Math.max(dp_i_1, dp_pre_0 - prices[i]); dp_pre_0 = temp; &#125; return dp_i_0;&#125; 3.4 k = +infinity with fee每次交易要支付手续费，只要把手续费从利润中减去即可。改写方程： 12dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee) 解释：相当于买入股票的价格升高了。在第一个式子里减也是一样的，相当于卖出股票的价格减小了。直接翻译成代码： 1234567891011int maxProfit_with_fee(int[] prices, int fee) &#123; int n = prices.length; int dp_i_0 = 0; int dp_i_1 = Integer.MIN_VALUE; for (int i = 0; i &lt; n; i++) &#123; int temp = dp_i_0; dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]); dp_i_1 = Math.max(dp_i_1, temp - prices[i] - fee); &#125; return dp_i_0;&#125; 3.5 k = 2k = 2 和前面题目的情况稍微不同，因为上面的情况都和 k 的关系不太大。要么 k 是正无穷，状态转移和 k 没关系了；要么 k = 1，跟 k = 0 这个 base case 挨得近，最后也没有存在感。 这道题 k = 2 和后面要讲的 k 是任意正整数的情况中，对 k 的处理就凸显出来了。我们直接写代码，边写边分析原因。 原始的动态转移方程，没有可化简的地方 12dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) 按照之前的代码，我们可能想当然这样写代码（错误的）： 12345678int k = 2;int[][][] dp = new int[n][k + 1][2];for (int i = 0; i &lt; n; i++) if (i - 1 == -1) &#123; /* 处理一下 base case*/ &#125; dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]); dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);&#125;return dp[n - 1][k][0]; 为什么错误？我这不是照着状态转移方程写的吗？ 还记得前面总结的「穷举框架」吗？就是说我们必须穷举所有状态。其实我们之前的解法，都在穷举所有状态，只是之前的题目中 k 都被化简掉了。这道题由于没有消掉 k 的影响，所以必须要对 k 进行穷举： 1234567891011int max_k = 2;int[][][] dp = new int[n][max_k + 1][2];for (int i = 0; i &lt; n; i++) &#123; for (int k = max_k; k &gt;= 1; k--) &#123; if (i - 1 == -1) &#123; /*处理 base case */ &#125; dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]); dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]); &#125;&#125;// 穷举了 n × max_k × 2 个状态，正确。return dp[n - 1][max_k][0]; 如果你不理解，可以返回第一点「穷举框架」重新阅读体会一下。 这里 k 取值范围比较小，所以可以不用 for 循环，直接把 k = 1 和 2 的情况手动列举出来也可以： 12345678910111213141516dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])dp[i][1][1] = max(dp[i-1][1][1], -prices[i])int maxProfit_k_2(int[] prices) &#123; int dp_i10 = 0, dp_i11 = Integer.MIN_VALUE; int dp_i20 = 0, dp_i21 = Integer.MIN_VALUE; for (int price : prices) &#123; dp_i20 = Math.max(dp_i20, dp_i21 + price); dp_i21 = Math.max(dp_i21, dp_i10 - price); dp_i10 = Math.max(dp_i10, dp_i11 + price); dp_i11 = Math.max(dp_i11, -price); &#125; return dp_i20;&#125; 有状态转移方程和含义明确的变量名指导，相信你很容易看懂。其实我们可以故弄玄虚，把上述四个变量换成 a, b, c, d。这样当别人看到你的代码时就会一头雾水，大惊失色，不得不对你肃然起敬。 3.6 k = any integer有了上一题 k = 2 的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的 k 值会非常大，dp 数组太大了。现在想想，交易次数 k 最多有多大呢？ 一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 k 应该不超过 n/2，如果超过，就没有约束作用了，相当于 k = +infinity。这种情况是之前解决过的。 直接把之前的代码重用： 12345678910111213int maxProfit_k_any(int max_k, int[] prices) &#123; int n = prices.length; if (max_k &gt; n / 2) return maxProfit_k_inf(prices); int[][][] dp = new int[n][max_k + 1][2]; for (int i = 0; i &lt; n; i++) for (int k = max_k; k &gt;= 1; k--) &#123; if (i - 1 == -1) &#123; /* 处理 base case */ &#125; dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]); dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]); &#125; return dp[n - 1][max_k][0];&#125; 至此，6 道题目通过一个状态转移方程全部解决。 4 最后总结本文给大家讲了如何通过状态转移的方法解决复杂的问题，用一个状态转移方程秒杀了 6 道股票买卖问题，现在想想，其实也不算难对吧？这已经属于动态规划问题中较困难的了。 关键就在于列举出所有可能的「状态」，然后想想怎么穷举更新这些「状态」。一般用一个多维 dp 数组储存这些状态，从 base case 开始向后推进，推进到最后的状态，就是我们想要的答案。想想这个过程，你是不是有点理解「动态规划」这个名词的意义了呢？ 具体到股票买卖问题，我们发现了三个状态，使用了一个三维数组，无非还是穷举 + 更新，不过我们可以说的高大上一点，这叫「三维 DP」，怕不怕？这个大实话一说，立刻显得你高人一等，名利双收有没有。 所以，大家不要被各种高大上的名词吓到，再多的困难问题，奇技淫巧，也不过是基本套路的不断升级组合产生的。只要把住算法的底层原理，即可举一反三，逐个击破。 5 相关题目[买卖股票的最佳时机][https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/] [买卖股票的最佳时机 II][https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/] [买卖股票的最佳时机 III][https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/] [买卖股票的最佳时机 IV][https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/] [最佳买卖股票时机含冷冻期][https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/] [买卖股票的最佳时机含手续费][https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>easy</tag>
        <tag>medium</tag>
        <tag>dp</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[M322-零钱兑换]]></title>
    <url>%2F2020%2F03%2F08%2FM322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。 如果没有任何一种硬币组合能组成总金额，返回 -1。 示例 1: 输入: coins = [1, 2, 5], amount = 11输出: 3解释: 11 = 5 + 5 + 1示例 2: 输入: coins = [2], amount = 3输出: -1说明:你可以认为每种硬币的数量是无限的。 方法一：动态规划 dp(n)=\left \{ \begin{array} \\ -1, n \lt 0 \\ 0, n = 0 \\ \min\{dp(n-coin) + 1 | coin \in coins \}, n \gt 0 \\ \end{array} \right .1234567891011121314151617181920212223class Solution &#123;public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; if (amount &lt; 0) &#123; return -1; &#125; vector&lt;int&gt; dp(amount + 1, amount + 1); dp[0] = 0; int size = amount + 1; for (int i = 1; i &lt; size; i++) &#123; for (int coin : coins) &#123; if (i - coin &lt; 0) &#123; continue; &#125; else &#123; dp[i] = min(dp[i], dp[i - coin] + 1); &#125; &#125; &#125; return (dp[amount] == amount + 1) ? -1 : dp[amount]; &#125;&#125;; 方法二：贪心+dfs贪心 想要总硬币数最少，肯定是优先用大面值硬币，所以对 coins 按从大到小排序 先丢大硬币，再丢会超过总额时，就可以递归下一层丢的是稍小面值的硬币 乘法对加法的加速 优先丢大硬币进去尝试，也没必要一个一个丢，可以用乘法算一下最多能丢几个 如果因为丢多了导致最后无法凑出总额，再回溯减少大硬币数量,最先找到的并不是最优解 123i = amount / coins[cIdx] // 计算最大能投几个amount - i * coins[cIdx] // 减去扔了i个硬币count + i // 加i个硬币 注意不是现实中发行的硬币，面值组合规划合理，会有奇葩情况 考虑到有 $[1,7,10]$ 这种用例，按照贪心思路$10 + 1 + 1 + 1 + 1$会比$7 + 7$更早找到，所以还是需要把所有情况都递归完 res 疯狂剪枝 贪心虽然得不到最优解，但也不是没用的 我们快速算出一个贪心的res之后，虽然还会有奇葩情况，但是绝大部分普通情况就可以疯狂剪枝了 123456789101112131415161718192021222324252627class Solution &#123;public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; if (amount &lt; 0) &#123; return -1; &#125; sort(coins.rbegin(), coins.rend()); int res = INT_MAX; dfs(coins, amount, 0, 0, res); return res == INT_MAX ? -1 : res; &#125; void dfs(vector&lt;int&gt;&amp; coins, int amount, int cIdx, int count, int&amp; res) &#123; if (amount == 0) &#123; res = min(res, count); return; &#125; if (cIdx == coins.size()) &#123; return; &#125; for (int i = amount / coins[cIdx]; i &gt;= 0 &amp;&amp; count + i &lt; res; i--) &#123; dfs(coins, amount - i * coins[cIdx], cIdx + 1, count + i, res); &#125; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>dp</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用排序算法详解]]></title>
    <url>%2F2020%2F03%2F02%2F%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[排序算法Playground在线运行地址：https://leetcode-cn.com/playground/rKzLfEEY/ 排序算法 平均时间复杂度 最好情况 最坏情况 空间复杂度 排序方式 稳定性 冒泡排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ In-place 稳定 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ In-place 不稳定 插入排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ In-place 稳定 希尔排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ $O(1)$ In-place 不稳定 归并排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ $O(n)$ Out-place 稳定 快速排序 $O(nlogn)$ $O(nlogn)$ $O(n^2)$ $O(logn)$ In-place 不稳定 堆排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ $O(1)$ In-place 不稳定 计数排序 $O(n+k)$ $O(n+k)$ $O(n+k)$ $O(k)$ Out-place 稳定 桶排序 $O(n+k)$ $O(n+k)$ $O(n^2)$ $O(n+k)$ Out-place 稳定 基数排序 $O(n×k)$ $O(n×k)$ $O(n×k)$ $O(n+k)$ Out-place 稳定 注： 稳定性：相同数字是否保持原顺序 排序方式：是否需要占据额外空间，需要为Out-place，不需要为In-place 以下代码实现均为升序（小→大）（除堆外） 冒泡排序思想：遍历数组n次（n为数的个数），比较两个数的大小，较大的数下沉，较小的数上浮。 12345678910void bubble_sort(vector&lt;int&gt;&amp; arr) &#123; int size = arr.size(); for (int i = 0; i &lt; size - 1; i++) &#123; // 表示第i轮 for (int j = size - 1; j &gt; i; j--) &#123; // 从最后一个数开始依次向前比较，由于每次将最小的数浮到水面（即i）以上，因此每过一轮，需要比较的次数就变少一次 if (arr[j] &lt; arr[j-1]) &#123; swap(arr[j], arr[j-1]); &#125; &#125; &#125;&#125; 优化：由于数据顺序排好以后，冒泡算法仍然会进行下一轮的比较，尽管后面的遍历都是多余的。因此，设置标志位，若某一轮没有发生交换，则结束排序。 12345678910111213141516void bubble_sort_op(vector&lt;int&gt;&amp; arr) &#123; int size = arr.size(); bool flag = false; for (int i = 0; i &lt; size - 1; i++) &#123; flag = false; for (int j = size - 1; j &gt; i; j--) &#123; if (arr[j] &lt; arr[j-1]) &#123; swap(arr[j], arr[j-1]); flag = true; &#125; &#125; if (!flag) &#123; break; &#125; &#125;&#125; 选择排序思想：每次选择数组中剩余数中最小的，将其放到前面（与对应位置的数交换）。 123456789101112void selection_sort(vector&lt;int&gt;&amp; arr) &#123; int size = arr.size(); for (int i = 0; i &lt; size - 1; i++) &#123; int minIdx = i; for (int j = size - 1; j &gt; i; j--) &#123; if (arr[j] &lt; arr[minIdx]) &#123; minIdx = j; &#125; &#125; swap(arr[i], arr[minIdx]); &#125;&#125; 插入排序思想：遍历数组，第k个数分别与前k-1个数比较，找到自己的位置并插入（实现上还是用的交换）。 123456789101112void insertion_sort(vector&lt;int&gt;&amp; arr) &#123; int size = arr.size(); for (int i = 1; i &lt; size; i++) &#123; // 表示第i轮 for (int j = i; j &gt; 0; j--) &#123; // 从第二个数开始，与前面的数依次比较，直到找到位置 if (arr[j] &lt; arr[j-1]) &#123; swap(arr[j], arr[j-1]); &#125; else &#123; break; &#125; &#125; &#125;&#125; 希尔排序思想：又叫最小增量排序，将要排序的数组根据某个增量分为若干子序列，并对子序列进行插入排序，然后将增量逐渐缩小，重复上述过程，直至增量为1，此时数组基本有序，最后再进行插入排序。 帮助理解： 假设有一组数据： 59 20 17 13 28 14 23 83 第一轮：增量为4（子序列为[0, 4], [1, 5], [2, 6], [3, 7]) 首先i=4，即选中arr[4]即28，将其与arr[4-4]即59作为一个子序列进行插入排序，结果为： 28 20 17 13 59 14 23 83 接着i=5，即选中arr[5]即14，将其与arr[5-4]即20作为一个子序列进行插入排序，结果为： 28 14 17 13 59 20 23 83 接着i=6，即选中arr[6]即23，将其与arr[6-4]即17作为一个子序列进行插入排序，由于17&lt;23，序列不变； 接着i=7，即选中arr[7]即83，将其与arr[5-4]即13作为一个子序列进行插入排序，由于13&lt;83，序列不变； 最终结果为： 28 14 17 13 59 20 23 83 第二轮：增量为2（子序列为[0, 2, 4, 6], [1, 3, 5, 7]) 结果为： 17 13 23 14 28 20 59 83 第三轮：增量为1 即将整个数组作为序列进行插入排序，结果为： 13 14 17 20 23 28 59 83 1234567891011121314void shell_sort(vector&lt;int&gt;&amp; arr) &#123; int size = arr.size(); for (int incr = size / 2; incr &gt; 0; incr /= 2) &#123; // 表示增量increment for (int i = incr; i &lt; size; i++) &#123; // 根据增量划分子序列并进行插入排序 for(int j = i; j &gt;= incr; j -= incr) &#123; if (arr[j-incr] &gt; arr[j]) &#123; swap(arr[j], arr[j-incr]); &#125; else &#123; break; &#125; &#125; &#125; &#125;&#125; 归并排序思想：分治法，将数组分成两组A，B，如果A，B组内有序，那么归并这两个子序列就得到了有序序列，为了使A，B有序，以此类推，将A，B分别再分成两组，如此分下去，直到每个组内只有一个数字时，该子序列就达到了有序，最后我们将相邻子序列两两归并即可。 动态版： ![](https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200303015136.gif) 静态版： ![](https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200303015137.jpg) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void merge_sort(vector&lt;int&gt;&amp; arr, int begin, int end) &#123; if (begin &lt; end) &#123; int mid = (begin + end) / 2; merge_sort(arr, begin, mid); // 将左半部分排好序 merge_sort(arr, mid + 1, end); // 将右半部分排好序 merge(arr, begin, mid, end); // 归并左右部分 &#125;&#125;void merge(vector&lt;int&gt;&amp; arr, int begin, int mid, int end) &#123; int i = 0; int j = 0; int k = 0; int size = end - begin + 1; vector&lt;int&gt; temp(size, 0); int pLeft = begin; int pRight = mid + 1; bool endLeft = false; bool endRight = false; for (i = 0; i &lt; size; i++) &#123; if (!endLeft &amp;&amp; !endRight) &#123; // 若左右序列均未到达终点 if (arr[pLeft] &lt; arr[pRight]) &#123; // 取左右指针所指向元素中较小的那一个 temp[i] = arr[pLeft++]; &#125; else &#123; temp[i] = arr[pRight++]; &#125; if (pLeft &gt; mid) &#123; // 判定左右序列是否已到达终点，若是则标记 endLeft = true; &#125; if (pRight &gt; end) &#123; endRight = true; &#125; &#125; else &#123; // 若左右至少有一个已经到达终点，则将未到达终点的序列剩余部分加在temp后面 if (!endLeft) &#123; temp[i] = arr[pLeft++]; &#125; else &#123; temp[i] = arr[pRight++]; &#125; &#125; &#125; for (j = 0, k = begin; j &lt; size; j++, k++) &#123; // 将temp中的数按序存回arr arr[k] = temp[j]; &#125;&#125; 快速排序思想：分治法，先从序列中选出一个数作为pivot，将比这个数小的数放在其左边，大的数放在其右边。然后，对左右两个子序列重复上一步，直至各子区间内只有一个数。 动态版： ![](https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200303190241.gif) 帮助理解： 例如，我们有这样一组序列：72 6 57 88 60 85 42 83 73 48，初始化pivot=60（这里的pivot为arr[begin], arr[mid], arr[end]的中间值），将其交换至末尾。 对该序列进行划分： 72 6 57 88 85 42 83 73 48 60 l r pivot 48 6 57 88 85 42 83 73 72 60 l r pivot 48 6 57 42 85 88 83 73 72 60 r l pivot 48 6 57 42 60 88 83 73 72 85 r l . 对[48, 6, 57 ,42]，[88, 83, 73, 72, 85]进行划分：正好各自的pivot都在末尾。 48 6 57 42 - 88 83 73 72 85 l1 r1 pivot1 - l2 r2 pivot2 48 6 57 42 - 75 83 73 88 85 l1 r1 pivot1 - r2 l2 pivot2 6 48 57 42 - 75 83 73 85 88 r1 l1 pivot1 - r2 l2 6 42 57 48 - r1 l1 - . [6], [88]不用划分，对[57, 48]，[75, 83, 73]划分：前者pivot=48，后者pivot=75，交换至末尾 - - 57 48 - 73 83 75 - - - - l1, r1 pivot1 - l1 r1 pivot2 - - - - 48 57 - 73 83 75 - - - - l1, r1 - r1 l1 pivot2 - - - - - 73 75 83 - - - - - r1 l1 - - 至此，排序完成。 最终序列为： 6 42 48 57 60 73 75 83 85 88 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051int find_pivot(vector&lt;int&gt;&amp; arr, int begin, int end) &#123; // 返回arr[begin], arr[mid], arr[end]的中间值 int mid = (begin + end) &gt;&gt; 1; if (arr[begin] &lt; arr[end]) &#123; if (arr[end] &lt; arr[mid]) &#123; return end; &#125; else if (arr[begin] &gt; arr[mid]) &#123; return begin; &#125; else &#123; return mid; &#125; &#125; else &#123; if (arr[end] &gt; arr[mid]) &#123; return end; &#125; else if (arr[begin] &lt; arr[mid]) &#123; return begin; &#125; else &#123; return mid; &#125; &#125;&#125;int partition(vector&lt;int&gt;&amp; arr, int begin, int end, int pivot) &#123; while (true) &#123; while (arr[begin] &lt; pivot) &#123; // 从左开始找到第一个比pivot大的值 begin++; &#125; end--; // 调整（若不调整，会将放在end处的pivot交换到别的位置） while (arr[end] &gt; pivot) &#123; // 从右开始找到第一个比pivot小的值 end--; &#125; if (begin &gt;= end) &#123; return begin; // 返回比pivot大的第一个值，即右序列的第一个位置 &#125; else &#123; swap(arr[begin], arr[end]); begin++; // 调整 &#125; &#125;&#125;void quick_sort(vector&lt;int&gt;&amp; arr, int begin, int end) &#123; if (begin &gt;= end) &#123; return; &#125; else &#123; int pivotIdx = find_pivot(arr, begin, end); swap(arr[pivotIdx], arr[end]); // 将pivot放在序列末尾 int bgRight = partition(arr, begin, end, arr[end]); // partition的返回值为右序列（比pivot大）的第一个位置，注意pivot已经被交换到末尾，故传入的pivot为arr[end] swap(arr[bgRight], arr[end]); // 将pivot值放回中间，使左序列比pivot大，右序列比pivot小 quick_sort(arr, begin, bgRight-1); // 对左序列重新排序 quick_sort(arr, bgRight+1, end); // 对右序列重新排序 &#125;&#125; 堆排序思想：binary heap就是一种完全二叉树，每个节点的值均大于等于其子节点的值。 静态版（大顶堆）： ![](https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200304175428.jpg) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class HEAP &#123;private: int heapSize; vector&lt;int&gt; harr;public: HEAP() &#123; heapSize = 0; &#125; HEAP(vector&lt;int&gt;::iterator begin, vector&lt;int&gt;::iterator end) &#123; heapSize = 0; for (auto it = begin; it != end; it++) &#123; insert(*it); &#125; &#125; int parent(int i) &#123; return (i - 1) / 2; &#125; int left(int i) &#123; return 2 * i + 1; &#125; int right(int i) &#123; return 2 * i + 2; &#125; void display() &#123; for (int i = 0; i &lt; heapSize; i++) &#123; cout &lt;&lt; harr[i] &lt;&lt; " "; &#125; &#125; void insert(int num) &#123; harr.push_back(num); // 将新数插入至末尾 heapSize++; int idx = heapSize - 1; // 取新数的索引 while (idx &gt;= 0 &amp;&amp; harr[parent(idx)] &gt; harr[idx]) &#123; // 将新数交换至正确的位置 swap(harr[parent(idx)], harr[idx]); idx = parent(idx); &#125; for (int i = 0; i &lt; heapSize; i++) &#123; cout &lt;&lt; harr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; void minheapify(int idx, int boundry) &#123; int leftIdx = left(idx); // 取idx左边子节点 int rightIdx = right(idx); // 取idx右边子节点 if (leftIdx &gt;= boundry || rightIdx &gt;= boundry) &#123; // 判断剩余元素是否已经成堆 return ; &#125; int minIdx = idx; // 记录最小元素的索引 if (harr[leftIdx] &lt; harr[idx]) &#123; minIdx = leftIdx; &#125; if (harr[rightIdx] &lt; harr[minIdx]) &#123; minIdx = rightIdx; &#125; if (minIdx != idx) &#123; swap(harr[idx], harr[minIdx]); minheapify(minIdx, boundry); &#125; &#125; vector&lt;int&gt; sort() &#123; for (int i = 1; i &lt; heapSize - 1; i++) &#123; swap(harr[0], harr[heapSize - i]); // 每次将最小元素移到后面去（移出堆中） minheapify(0, heapSize - i); // 将剩下的元素重新调节成最小堆 &#125; if (harr[0] &lt; harr[1]) &#123; swap(harr[0], harr[1]); &#125; return harr; &#125;&#125;; 计数排序思想：空间换取时间，计算每个数的次数，最后遍历并存入原数组。 1234567891011121314151617181920void counting_sort(vector&lt;int&gt;&amp; arr) &#123; int maxNum = INT_MIN; int size = arr.size(); for (int i = 0; i &lt; size; i++) &#123; maxNum = max(maxNum, arr[i]); &#125; int range = maxNum + 1; vector&lt;int&gt; temp(range, 0); for (int i = 0; i &lt; size; i++) &#123; // 计数 ++temp[arr[i]]; &#125; for (int i = 0, j = -1; i &lt; range; i++) &#123; // 遍历每个数槽 for (int k = 0; k &lt; temp[i]; k++) &#123; // 取出该数，直到达到之前的计数 arr[++j] = i; &#125; &#125;&#125; 优化：创建max-min+1个空间，减少空间浪费 12345678910111213141516171819202122void counting_sort_op(vector&lt;int&gt;&amp; arr) &#123; int maxNum = INT_MIN; int minNum = INT_MAX; int size = arr.size(); for (int i = 0; i &lt; size; i++) &#123; maxNum = max(maxNum, arr[i]); minNum = min(minNum, arr[i]); &#125; int range = maxNum - minNum + 1; vector&lt;int&gt; temp(range, 0); for (int i = 0; i &lt; size; i++) &#123; temp[arr[i]-minNum]++; &#125; for (int i = 0, j = -1; i &lt; range; i++) &#123; for (int k = 0; k &lt; temp[i]; k++) &#123; arr[++j] = i + minNum; &#125; &#125;&#125; 桶排序思想：分治法，桶排序是计数排序的扩展版本，计数排序可以看成每个桶只存储相同元素，桶排序每个桶存储一定范围的元素，通过映射函数，将待排序数组中的元素映射到各个对应的桶中，对每个桶中的元素进行排序，最后将非空桶中的元素逐个放入原序列中。 静态版： ![](https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200303234808.png) 123456789101112131415161718192021222324252627void bucket_sort(vector&lt;int&gt;&amp; arr) &#123; int size = arr.size(); vector&lt;int&gt; temp[size]; int maxNum = INT_MIN; int minNum = INT_MAX; for (int i = 0; i &lt; size; i++) &#123; // 确定最大最小值 maxNum = max(maxNum, arr[i]); minNum = min(minNum, arr[i]); &#125; for (int i = 0; i &lt; size; i++) &#123; int bucketNum = (int)(arr[i] - minNum) / (maxNum - minNum + 1) * size; // 加1是为了确保bucketNum &lt; size temp[bucketNum].push_back(arr[i]); &#125; for (int i = 0; i &lt; size; i++) &#123; // 将每个桶内排序 sort(temp[i].begin(), temp[i].end()); &#125; int idx = 0; for (int i = 0; i &lt; size; i++) &#123; // 按序将桶内排好序的数字拷回arr for (int j = 0; j &lt; temp[i].size(); j++) &#123; arr[idx++] = temp[i][j]; &#125; &#125;&#125; 基数排序思想：首先了解分配排序(binsort)，即创建数组A[MaxValue]；然后将每个数放到相应的位置上（例如17放在下标17的数组位置）；最后遍历数组，即为排序后的结果。 静态版： ![](https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200304005951.jpg) 问题在于，当序列中的元素分布不集中时，会造成大量的空间开销。 基数排序即在此基础上，通过基数的限制减少空间开销。 静态版： ![](https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200304010131.jpg) ![](https://hexo-jiangluyu.oss-cn-shanghai.aliyuncs.com/20200304010147.jpg) 123456789101112131415161718192021222324252627282930313233void count_sort(vector&lt;int&gt;&amp; arr, int exp) &#123; int size = arr.size(); vector&lt;int&gt; temp(size, 0); vector&lt;int&gt; count(10, 0); for (int i = 0; i &lt; size; i++) &#123; // 计算在第exp位的每个数字出现的次数 count[(arr[i] / exp) % 10]++; &#125; for (int i = 1; i &lt; 10; i++) &#123; // 计算累计数量 count[i] += count[i-1]; &#125; for (int i = size - 1; i &gt;= 0; i--) &#123; temp[count[(arr[i] / exp) % 10] - 1] = arr[i]; count[(arr[i] / exp) % 10]--; &#125; arr = temp;&#125;void radix_sort(vector&lt;int&gt;&amp; arr) &#123; int maxNum = INT_MIN; int size = arr.size(); int exp = 0; // 记录最大数的位数 for (int i = 0; i &lt; size; i++) &#123; maxNum = max(maxNum, arr[i]); &#125; for (exp = 1; maxNum / exp &gt; 0; exp *= 10) &#123; count_sort(arr, exp); &#125;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[今日母亲为我理发]]></title>
    <url>%2F2020%2F02%2F29%2F%E4%BB%8A%E6%97%A5%E6%AF%8D%E4%BA%B2%E4%B8%BA%E6%88%91%E7%90%86%E5%8F%91%2F</url>
    <content type="text"><![CDATA[因疫情缘故， 头发极长， 于是今日母亲用网购来的推子与剪子， 为我们爷俩剪了头， 十分满意。 父亲发型阴差阳错， 甚是新潮。]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>活在此时</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++set详解]]></title>
    <url>%2F2020%2F02%2F27%2FC%2B%2Bset%2F</url>
    <content type="text"><![CDATA[关于C++ STL set的用法以及知识延伸。 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int main(void)&#123; set&lt;int&gt; nums; for (int i = 0; i &lt; 10; i++) &#123; nums.insert(i); &#125; // 等效 set&lt;int&gt;::iterator it = nums.begin(); auto it = nums.begin(); for (it; it != nums.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; endl; &#125;&#125; 常见用法1234567891011121314151617181920212223242526272829303132333435363738begin() // 返回指向set容器第一个元素的迭代器end() // 返回指向set容器最后一个元素的迭代器，不存值 rbegin() // 等效end() rend() // 等效begin() clear() // 清空set容器 empty() // 判断set容器是否为空 max_size() // 返回set容器可能包含元素的最大个数 size() // 返回当前set容器中的元素个数 insert(x) // 向set容器中插入值x，返回值为pair&lt;it, bool&gt;，bool表示是否成功，it指向x在set中的位置 insert(it_start, it_end) // 向set中插入两迭代器中间的值 erase(x) // 从set容器中删除值x，若x为迭代器，则删除迭代器指向的值 erase(it_start, it_end) // 删除set中两迭代器中间的值，包括*it_start，不包括*it_end count(x) // 计算set中x出现的次数，在set中只可能为1或0 find(x) // 若找到x，则返回指向x的迭代器，否则返回end() lower_bound(x) // 返回指向第一个大于等于x的值的迭代器 upper_bound(x) // 返回指向第一个大于x的值的迭代器// 返回pair&lt;it, it&gt;，即在两迭代器内，所有等于x的值的范围，即第一个x的位置与最后一个x的位置，set中若不存在x则两值相等equal_range(it_begin, it_end, x) set1.insert(set2.begin(), set3.end()) // set1 = set2 ∪ set3 并去重set1.swap(set2) // 两个set内容交换 知识延伸map和set插入删除效率比其他序列容器高的原因： 底层实现为红黑树，对于关联容器来说，不需要做内存拷贝和内存移动。set容器内所有元素都是以节点的方式来存储，其节点结构和链表差不多，指向父节点和子节点。 map在每次insert、erase操作之后，以前的迭代器是否会过期？ 不会，注意vector在进行相应操作后迭代器可能会过期。 插入、搜索元素时，效率如何？ set中使用的是二分查找，时间复杂度为logn，换言之，数据增大一倍时，搜索次数会多1次。 如何求并集、交集、差集、对称差集（A∪B-A∩B）？ 1234567891011121314&gt; #include &lt;algorithm&gt;&gt; &gt; // 交集&gt; set_intersection(it1_start, it1_end, it2_start, it2_end, inserter(res, res.begin()))&gt; &gt; // 差集&gt; set_difference(it1_start, it1_end, it2_start, it2_end, inserter(res, res.begin()))&gt; &gt; // 并集&gt; set_union(it1_start, it1_end, it2_start, it2_end, inserter(res, res.begin()))&gt; &gt; // 对称差集&gt; set_symmetry_difference(it1_start, it1_end, it2_start, it2_end, inserter(res, res.begin()))&gt;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[E021-合并两个有序链表]]></title>
    <url>%2F2020%2F02%2F21%2FE021-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 方法一：递归思路即每次挑选一个“头”节点，在剩下的节点中再递归挑选“头”节点，直至有一个链表被挑光，即为空。 1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if (l1 == NULL) &#123; return l2; &#125; else if (l2 == NULL) &#123; return l1; &#125; if (l1-&gt;val &lt; l2-&gt;val) &#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; else &#123; l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; &#125; &#125;&#125;; 复杂度分析 时间复杂度：O(m + n)，m，n分别为l1,l2的元素个数。递归函数每次去掉一个元素，直到两个链表都为空，因此需要调用R=O(m + n)次。而在递归函数中我们只进行了next指针的赋值操作，复杂度为O(1)，故递归的总时间复杂度为O(m + n)。 空间复杂度：O(m + n)，递归调用了该函数m + n次，使用了m + n个栈帧，故空间复杂度为O(m + n)。 方法二：迭代用一个prev指针维护当前接在结果中的最后一个节点，每次迭代要做的就是决定l1与l2中哪一个的剩余头节点成为prev-&gt;next。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if (l1 == NULL) &#123; return l2; &#125; else if (l2 == NULL) &#123; return l1; &#125; ListNode* resHead = NULL; if (l1-&gt;val &lt; l2-&gt;val) &#123; resHead = l1; l1 = l1-&gt;next; &#125; else&#123; resHead = l2; l2 = l2-&gt;next; &#125; ListNode* prev = resHead; while (l1 != NULL &amp;&amp; l2 != NULL) &#123; if (l1-&gt;val &lt; l2-&gt;val) &#123; prev-&gt;next = l1; prev = prev-&gt;next; l1 = l1-&gt;next; &#125; else &#123; prev-&gt;next = l2; prev = prev-&gt;next; l2 = l2-&gt;next; &#125; &#125; if (l1 == NULL) &#123; prev-&gt;next = l2; &#125; else if (l2 == NULL) &#123; prev-&gt;next = l1; &#125; return resHead; &#125;&#125;; 复杂度分析 时间复杂度：O(m + n)，m，n分别为l1,l2的元素个数，相当于遍历了两次较短链表的长度。 空间复杂度：O(1)，每次迭代只使用了同一个prev指针，因此为常数级复杂度。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>easy</tag>
        <tag>recursion</tag>
        <tag>iteration</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电脑维修实用问题汇总]]></title>
    <url>%2F2020%2F02%2F21%2F%E7%94%B5%E8%84%91%E7%BB%B4%E4%BF%AE%E5%AE%9E%E7%94%A8%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[一些常用问题汇总。 实用问题汇总：硬件 进水 进水的问题一定要马上和机主联系，不可耽误，如果没法第一时间接单，就让机主马上送去维修，或者将单子转给别的技术员，总之处理要快 询问机主是什么时候进的水？进的是什么水？进了多少水？进水之后做了什么？（如果遇上神仙机主，机子进水了还不拆开开始晒干，等过了一两天才找你，甚至进完水没多久觉得可以了还开机的，这种单子最好就别接了） 如果还来得及，提醒机主一定不能开机，再接到机子后，首先把电源拆掉（个人建议这里别放静电，放了有可能出事），如果发现进水量过大，已经渗入主板内，先用纸把周围的水吸附掉，把硬盘拆下来（电脑出问题优先保住硬盘），继续吸附水，然后接着拆，以此循环，把能吸附的水吸附掉后，视情况建议机主送去维修店烘干。如果倒入的是饮料。。。尽力而为吧，某些地方可以用酒精纸（不过多半救不了），同样能处理完后让机主送去维修 如果以上更糟糕的情况没有发生，则将拆开后的本子和配件放在通风处（不能让阳光直射），等待晾干，原则上是至少要晾3天 清灰 顺序：拆机→清理风扇→清理其他→装机 注意：分清螺丝、视电脑拆机难度，决定拆机层次，结构比较复杂的尽量降低拆机的层次（但依然要把电池拆下来）、用皮老虎，角度尽量贴近风扇平面，对着扇叶吹，吹的方向应该是风扇靠近笔记本边缘的方向，以免吹出来的灰尘落到元件上，吹的过程中可用小刷子擦拭扇叶，帮助清理。吹完后，用小刷子轻轻扫过平面，将残留的灰尘扫出去。最后用皮老虎再吹，如果基本没有灰尘吹出，则差不多清理完毕 花屏 有能力的可以拆屏幕框重新插拔排线，否则直接建议机主售后 扩容 硬盘：注意主板接口与硬盘接口是否匹配（要熟知常见的接口！） 内存：注意内存的接口类型（DDR3、DDR3L、DDR4）以及频率（向下兼容，按最低的算） 软件 系统 系统镜像去MSDN下载原版 制作PE盘（去微PE官网下载或使用飞扬的镜像，其实是一个东西） 激活使用KMS（建议使用胡萝卜周博客中下载的版本） 常用软件（常备安装文件！安装失败时注意错误代码！） 驱动人生、驱动精灵，重装电脑时使用装机版，其他情况下只有当有问题时才尝试升级、重装驱动，不要随意升级其他正常工作的驱动！ Microsoft Office Adobe AutoCAD 注：在安装CAD等软件过程中报错，比起直接搜索“安装到哪里不动“”安装XXX出错”，先查看这类软件的安装日志，看看安装日志是在哪一步失败，再推断和搜索安装原因是最高效、最准确的（如果你找得到安装日志的话，大部分的软件应该都有，因为写他们的程序员自己也要看） 常见问题Q1：网页打不开 检查网络连接是否正常 检查是否启动代理（SSR之类），小飞机启动后选择关闭有时也会导致无法打开网页 检查防火墙设置，将浏览器或其他连不了网络的软件添加至例外中 清除缓存与Cookie信息[IE中：工具→Internet选项→常规→浏览历史记录→删除]，CC登不上时常用 使用360断网急救箱 Q2：蓝牙连不上 检查是否打开蓝牙 检查是否开了飞行模式而自动关闭蓝牙 查看蓝牙驱动[设备管理器→蓝牙]，哪里不对，更新哪里 Win+R打开运行，输入services.msc，查看其中与蓝牙有关的服务项（如Bluetooth Support Service），如果有禁用的，则改为自动启动 麻烦的情况：能做的都做了，重启后有时可以有时不行（大概率在冬天），这是一个玄学问题，售后或者一般等天气回暖就好了 Q3：广告弹窗 打开任务管理器，定位弹窗广告的进程，右键选择“打开文件所在的位置”，打开后删掉或者卸载相关文件，并关掉对应的进程便可 如果不能确定哪个进程是弹窗广告的话，要进行试错，选择从没见过、从命名不能理解进程用途、非系统文件命名方式的进程，先打开文件所在位置，然后关掉进程，如果弹窗消失，说明找到了 部分弹窗运行文件删除的时候可能没有权限（真的非常流氓），可以进入Window10的安全模式（Win+R，输入msconfig，勾选安全引导，点击确定，重启电脑便好），再去相应的文件位置删除（安全模式能够自动获取权限） 如果机主反馈弹窗又重新出现，你发现原来的弹窗文件又生成了，而机主又不愿意卸载使其生成的软件（以金山毒霸为首），那么可以使用“偷天换日”的做法：复制弹窗对应的exe文件的文件名，将原来的文件删掉后，在原来的位置新建立一个txt文件，将文件名改为复制的文件名（记得修改后缀），然后右键改文件，点击“属性”，在“安全”中点击编辑，在权限窗口中勾选“拒绝”一栏，这样当软件想要读取的时候就会“哑火” 具体可参照这个链接：https://jingyan.baidu.com/article/3a2f7c2e51d76d67afd611be.html 常见的弹窗系软件：360系，爱奇艺，腾讯视频，2345系（好压、看图王等），搜狐系 懒人法：火绒的弹窗管理 Q4：电脑启动慢、卡顿 若电脑服役时间较久（有的甚至是没有SSD的年代的电脑），最好选择硬件升级 启动慢修改开机启动项：Win+R，输入msconfig，在常规一栏中选择有选择的启动，并勾选加载启动项，到启动一栏中对启动项进行调整 懒人法：火绒的启动项管理 Q5：系统重装 注意事项：询问机主是否需要备份，以及重装后需要重新安装的软件 Q6：电脑没声音 使用声音疑难解答[声音图标（右键）→声音问题疑难解答]（这个检测出的问题常常可以作为百度的关键词，比直接搜索问题要精准一点） 设置扬声器为默认设备[声音图标（右键）→打开音量合成器→系统声音→播放] 扬声器还原默认值[扬声器（右键）→高级→还原默认值] 检查驱动[开始图标右键→设备管理器（快捷键Win+X, M）→声音、视频和游戏控制器设备管理器→Realtek High Definition Audio（或Realtek Audio）]，使用驱动精灵进行重装或更新 存在特殊情况：笔记本插上耳机有声音，外放没声音。在以上方法排除后，依然出现这种情况，那么打开设备管理器，点击系统设备，找到英特尔智音技术控制器，右键点击选择更新驱动就好了，再选择“自动搜索”或者“浏览计算机”，如果是后者的话，应该选择的驱动是High Definition Audio（这个我找不到之前的解决链接了，按照记忆写了一下，找“智音技术”准没错） Q7：连不上网 无线网：（以下方法按顺序进行，若都无效可能是硬件问题，建议售后） 查看是否进入了飞行模式[右下角网络图标→飞行模式] 查看设备管理器中的驱动状态[左下角开始图标右键→设备管理器（快捷键Win+X, M）→网络适配器]，有线网一般是带有PCIe的字样，无线网一般是带有Wireless，如果对应驱动出现红叉或者警告标志，一般是驱动出了问题，更新或者重新安装就行了，没有的话，直接尝试重新安装 使用系统自带的疑难解答[右下角网络图标→设置→网络疑难解答] 尝试360断网急救箱 Win+R打开运行，输入cmd，在命令提示符中输入命令回车并重启： 1netsh winsock reset 较为麻烦的情况：网络列表上没有可连接的网络，设备管理器中找不到对应驱动，甚至在”网络和Internet”上找不到WLAN等表项，驱动精灵安装驱动时没有安装网卡驱动的选项，而且机主告诉你，他无线能用但有线不能或者反之或者皆不能，说明很有可能网卡硬件出了问题，拆机后对网卡重新插拔（注意记住连接网卡的两个小细线，连接的顺序和位置不能错）。要注意这个可插拔的网卡只管无线网！因此如果你再重新插拔后无线网依然没法用，或者以上情况中的主体是有线网，那么恭喜你，这电脑很有可能就修不好了（参照刘双嘉同学亲身经历）。这个麻烦情况大都出现在冬天，初步推断是硬件老化加上热胀冷缩引起的，建议送报修或者售后。 有线网：（以下方法按顺序进行，若都无效可能是硬件问题，建议售后） 检查网线是否插好，若仍提示网络电缆未插入可以尝试更换网线 使用系统自带的疑难解答[右下角网络图标→设置→网络疑难解答] 尝试360断网急救箱 Win+R打开运行，输入cmd，在命令提示符中输入命令回车并重启： 1netsh winsock reset 使用驱动精灵/驱动人生重新安装网卡驱动 写在后面除了动手以外，想做“好”的一定要对笔记本参数保持敏感，经常学习。 下面是一些推荐的信息源： 公众号：笔吧评测室 b站：翼王，Linus等 常用资源[软件安装] 微信公众号：软件安装管家 胡萝卜周博客（右上角放大镜检索）：http://www.carrotchou.blog MSDN：https://msdn.itellyou.cn/]]></content>
      <categories>
        <category>电脑维修</category>
      </categories>
      <tags>
        <tag>问题汇总</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[形近词辨析]]></title>
    <url>%2F2020%2F02%2F16%2F%E5%BD%A2%E8%BF%91%E8%AF%8D%E8%BE%A8%E6%9E%90%2F</url>
    <content type="text"><![CDATA[一些常用形近词整理。 precipitate v.使(坏事等)突然发生；使沉淀；使水蒸气凝结； a.仓促的，鲁莽的，突如其来的； n.沉淀物 percipient a.敏锐的，有洞察力的，理解透彻的 perceive v.觉察，发觉，发现，感知，理解 mobilization n.动员；调动 mobility n.可动性；能动性；灵活性 defer v.推迟；服从 deter v.阻止 conclusive a.确定性的，决定性的，无争论余地的 exclusive a.独有的，独占的（= only）；排外的；高级的 exclusively adv.唯一的 cranial a.颅的 cardinal a.首要的，基本的]]></content>
      <categories>
        <category>TOEFL</category>
        <category>GRE</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[独立口语思路练习]]></title>
    <url>%2F2020%2F02%2F15%2F%E7%8B%AC%E7%AB%8B%E5%8F%A3%E8%AF%AD%E6%80%9D%E8%B7%AF%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[新托福口语思路练习。 Q1: Smart phone &amp; navigational devices or ask the locals for direction?Main idea: the former Reason 1: professional —&gt; accurate, efficient Example 1: locals maybe do not know or give obsolete information —&gt; slower, while navigational devices are always up-to-date Reason 2: no need to care about language problem Example 2: cannot speak Japanese, Last year travel to Japan, Google Map —&gt; not miss any event planned]]></content>
      <categories>
        <category>TOEFL</category>
      </categories>
      <tags>
        <tag>口语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[托福答题模板（自用）]]></title>
    <url>%2F2020%2F02%2F15%2F%E6%89%98%E7%A6%8F%E7%AD%94%E9%A2%98%E6%A8%A1%E6%9D%BF%EF%BC%88%E8%87%AA%E7%94%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[新托福口语答题模板总结。 TASK 1graph TD; A(Main idea)-->B(Reason 1)-->C(Reason 2) Template: When …, I’d …/Well honestly, I (dis)agree with the idea. The most obvious reason is that + sub idea 1. In my case/Take my own experience for example, … Another reason is that + sub idea 2. To be more specific/Specifically speaking,… (Those are the reasons why I am for/against the idea.) TASK 2Template: UNIV： The university is going to/announces that…because/in order to… S/T： A student/teacher suggests university should…because/in order to… The man/woman (dis)agrees with the idea. He/She says that… TASK 3Template: The passage defines X as n. that… The professor elaborates on this with an example. …]]></content>
      <categories>
        <category>TOEFL</category>
      </categories>
      <tags>
        <tag>口语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[托福口语语料积累（更新中）]]></title>
    <url>%2F2020%2F02%2F15%2F%E6%89%98%E7%A6%8F%E5%8F%A3%E8%AF%AD%E8%AF%AD%E6%96%99%E7%A7%AF%E7%B4%AF%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[新托福口语语料总结。 句型 The most obvious reason is that…… In my case, …… Another reason is that…… 词组与help有关 turn to sb. for help = seek help from sb. be always around = be available with the help of sb. help sb., help sb. with sth., help sb. to do sth. offer sb. help, offer help to sb. provide sb. with help, provide help for sb. give sb. a hand]]></content>
      <categories>
        <category>TOEFL</category>
      </categories>
      <tags>
        <tag>口语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于hexo遇到的问题汇总]]></title>
    <url>%2F2020%2F02%2F15%2F%E5%85%B3%E4%BA%8Ehexo%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[一些迁移、安装hexo时遇到的问题及解决方法。 Q1: gyp: No Xcode or CLT version detected!近日在将hexo从win迁移到mac时，卡在了npm安装上： 运行如下命令时： 1npm install 出现如下错误： 123456789101112131415161718192021222324252627282930313233343536&gt; node installnode-pre-gyp WARN Tried to download(404): https://fsevents-binaries.s3-us-west-2.amazonaws.com/v1.2.4/fse-v1.2.4-node-v67-darwin-x64.tar.gznode-pre-gyp WARN Pre-built binaries not found for fsevents@1.2.4 and node@11.14.0 (node-v67 ABI, unknown) (falling back to source compile with node-gyp)No receipt for 'com.apple.pkg.CLTools_Executables' found at '/'.No receipt for 'com.apple.pkg.DeveloperToolsCLILeo' found at '/'.No receipt for 'com.apple.pkg.DeveloperToolsCLI' found at '/'.gyp: No Xcode or CLT version detected!gyp ERR! configure errorgyp ERR! stack Error: `gyp` failed with exit code: 1gyp ERR! stack at ChildProcess.onCpExit (/usr/local/lib/node_modules/npm/node_modules/node-gyp/lib/configure.js:351:16)gyp ERR! stack at ChildProcess.emit (events.js:193:13)gyp ERR! stack at Process.ChildProcess._handle.onexit (internal/child_process.js:255:12)gyp ERR! System Darwin 19.3.0gyp ERR! command "/usr/local/Cellar/node/11.14.0/bin/node" "/usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js" "configure" "--fallback-to-build" "--module=/Users/louis/Documents/GitHub/jiangluyu.github.io/node_modules/fsevents/lib/binding/Release/node-v67-darwin-x64/fse.node" "--module_name=fse" "--module_path=/Users/louis/Documents/GitHub/jiangluyu.github.io/node_modules/fsevents/lib/binding/Release/node-v67-darwin-x64" "--napi_version=4" "--node_abi_napi=napi"gyp ERR! cwd /Users/louis/Documents/GitHub/jiangluyu.github.io/node_modules/fseventsgyp ERR! node -v v11.14.0gyp ERR! node-gyp -v v5.0.7gyp ERR! not oknode-pre-gyp ERR! build errornode-pre-gyp ERR! stack Error: Failed to execute '/usr/local/Cellar/node/11.14.0/bin/node /usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js configure --fallback-to-build --module=/Users/louis/Documents/GitHub/jiangluyu.github.io/node_modules/fsevents/lib/binding/Release/node-v67-darwin-x64/fse.node --module_name=fse --module_path=/Users/louis/Documents/GitHub/jiangluyu.github.io/node_modules/fsevents/lib/binding/Release/node-v67-darwin-x64 --napi_version=4 --node_abi_napi=napi' (1)node-pre-gyp ERR! stack at ChildProcess.&lt;anonymous&gt; (/Users/louis/Documents/GitHub/jiangluyu.github.io/node_modules/fsevents/node_modules/node-pre-gyp/lib/util/compile.js:83:29)node-pre-gyp ERR! stack at ChildProcess.emit (events.js:193:13)node-pre-gyp ERR! stack at maybeClose (internal/child_process.js:999:16)node-pre-gyp ERR! stack at Process.ChildProcess._handle.onexit (internal/child_process.js:266:5)node-pre-gyp ERR! System Darwin 19.3.0node-pre-gyp ERR! command "/usr/local/Cellar/node/11.14.0/bin/node" "/Users/louis/Documents/GitHub/jiangluyu.github.io/node_modules/fsevents/node_modules/node-pre-gyp/bin/node-pre-gyp" "install" "--fallback-to-build"node-pre-gyp ERR! cwd /Users/louis/Documents/GitHub/jiangluyu.github.io/node_modules/fseventsnode-pre-gyp ERR! node -v v11.14.0node-pre-gyp ERR! node-pre-gyp -v v0.10.0node-pre-gyp ERR! not okFailed to execute '/usr/local/Cellar/node/11.14.0/bin/node /usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js configure --fallback-to-build --module=/Users/louis/Documents/GitHub/jiangluyu.github.io/node_modules/fsevents/lib/binding/Release/node-v67-darwin-x64/fse.node --module_name=fse --module_path=/Users/louis/Documents/GitHub/jiangluyu.github.io/node_modules/fsevents/lib/binding/Release/node-v67-darwin-x64 --napi_version=4 --node_abi_napi=napi' (1)...以下省略 实际上，在尝试过使用如下命令 1xcode-select --install 进行修复时，并不成功。 解决方案如下： 12sudo rm -rf $(xcode-select -print-path)xcode-select --install Q2: hexo迁移去年在原先的笔记本上建立的项目，彼时对github了解甚少，没想过在不同电脑上更新的需求，甚至还因此断更了一年（笑），迁移步骤如下： ssh配置好后，克隆github上yourname.github.io项目到本地： 1git clone https://github.com/yourname/yourname.github.io.git 删除除了.git以外的所有文件； 将blog源文件中的所有文件复制到xxx.github.io的文件夹中，并将theme文件夹中各个主题中的.git文件夹删除； 创建hexo分支，并切换到hexo： 1git checkout -b hexo 将复制的文件提交到暂存区，并提交，推送至github： 123git add .git commit -m 'new branch source files'git push --set-upstream origin hexo 更新blog时，只需要照常即可： 12hexo cleanhexo d -g 切换至新电脑时，只需要执行如下命令： 1git clone -b hexo https://github.com/yourname/yourname.github.io 在ssh配置正确，npm安装依赖后，即可更新。 Q3: 无法备份/themes在删掉themes中的所有主题的.git之后，发现使用如下命令： 123git add .git comment -m 'write your comment here'git push 依然无法成功将自己修改过的主题提交到github上。 解决方案如下：在确保删除了各个主题的.git文件后，执行如下命令： 1234git rm --cached -r themesgit add themesgit commit -m 'write your comment here'git push]]></content>
      <categories>
        <category>bugfix</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[E867-转置矩阵]]></title>
    <url>%2F2020%2F02%2F14%2FE867-%E8%BD%AC%E7%BD%AE%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[给定一个矩阵 A， 返回 A 的转置矩阵。 矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。 示例 1： 输入：[[1,2,3],[4,5,6],[7,8,9]]输出：[[1,4,7],[2,5,8],[3,6,9]]示例 2： 输入：[[1,2,3],[4,5,6]]输出：[[1,4],[2,5],[3,6]] 提示： 1 &lt;= A.length &lt;= 10001 &lt;= A[0].length &lt;= 1000 方法一：遍历复制重新创建一个vector，依照规律遍历并复制对应数字到所创建的vector中。 12345678910111213141516class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; transpose(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123; int col = A[0].size(); int row = A.size(); vector&lt;vector&lt;int&gt;&gt; res(col); for (int iRow = 0; iRow &lt; col; iRow++) &#123; for (int iCol = 0; iCol &lt; row; iCol++) &#123; res[iRow].push_back(A[iCol][iRow]); &#125; &#125; return res; &#125;&#125;; 复杂度分析 时间复杂度：O(M×N)，其中M与N分别为矩阵A的行数和列数。 空间复杂度：O(M×N)。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>easy</tag>
        <tag>iteration</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[E206-反转链表]]></title>
    <url>%2F2020%2F02%2F14%2FE206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[反转一个单链表。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 方法一：外部容器将链表转存至新的容器vector内，再利用vector本身的reverse_iterator进行反向遍历，将内容一一对应存入链表节点内。 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if (head == NULL) &#123; return head; &#125; vector&lt;int&gt; store; while (head != NULL) &#123; store.push_back(head-&gt;val); head = head-&gt;next; &#125; ListNode* resHead = new ListNode(0); ListNode* p = resHead; ListNode* q = nullptr; p-&gt;val = *(store.rbegin()); for (vector&lt;int&gt;::reverse_iterator riter = store.rbegin() + 1; riter != store.rend(); riter++) &#123; q = new ListNode(0); q-&gt;val = *riter; p-&gt;next = q; p = q; &#125; p-&gt;next = NULL; return resHead; &#125;&#125;; 复杂度分析 时间复杂度：O(n)，其中n为链表长度。 空间复杂度：O(n)。 方法二：迭代在遍历列表时，将当前节点的 next 指针改为指向它的前一个节点。分别需要一个指针用来记录上一个节点（previous），当前节点（current）以及下一个节点（next）。 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if (head == NULL) &#123; return head; &#125; ListNode* prev = nullptr; ListNode* curr = head; while (curr != NULL) &#123; ListNode* nextTemp = nullptr; nextTemp = curr-&gt;next; curr-&gt;next = prev; prev = curr; curr = nextTemp; &#125; return prev; &#125;&#125;; 复杂度分析 时间复杂度：O(n)，其中n为链表长度。 空间复杂度：O(1)。 方法三：递归递归方法比较难理解，假设我们传入的链表为1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL，那么传入的head即节点1，递归令节点curr等于reverseList(head-&gt;next)，终止条件为head或head-&gt;next为空，并返回head。 在这个例子中，最后一层返回的即节点5，此时head指向节点4，我们令head-&gt;next-&gt;next = head，即1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;4： 接着，令head-&gt;next = null，即1-&gt;2-&gt;3-&gt;4-&gt;null且5-&gt;4： 12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if (head == NULL || head-&gt;next == NULL) &#123; return head; &#125; ListNode* curr = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return curr; &#125;&#125;; 复杂度分析 时间复杂度：O(n)，其中n为链表长度。 空间复杂度：O(n)，递归至n层。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>easy</tag>
        <tag>recursion</tag>
        <tag>iteration</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[少少]]></title>
    <url>%2F2019%2F01%2F04%2F%E5%B0%91%E5%B0%91%2F</url>
    <content type="text"><![CDATA[“如果提前了解了你们的人生，不知你们是否还会有勇气前来？” 再想起这句台词，电影都不知是何日看的了，挺早的。 我想说，有啊，就是少点。 2018-2019的交界时，立了好多flag，还试着跟一波朋友圈网易云音乐flag的热潮，无奈轰趴的那个夜晚，明明显示着长按保存，我却怎么样都唤不出菜单。怎么回事？谁知道呢。我只知道，最后我放弃了，只在总结里添了一行信号微弱的粗浅论调。熬夜的后遗症还在，大致就是睡不醒醒就睡，萎靡着，空洞着，压缩着吃饭、喝水等等一切行动的欲望来恢复精力。 打卡到最后几个眼神都是迷离的，隐隐听着音响里的歌，再也不循环那个熟悉的、混杂的歌单了，随便什么，有声音就好，不是神曲就好，一个人的世界里，它们都有自己的声音。 喜欢美短，想取个名字叫辛巴(Simba)，而所有的不喜欢和不知道，是还没准备好。 出门就是一场义无反顾的冒险，不消多远，上厕所都赶时间，怕残羹被收走。相信世间温暖，禁不住旁人冷漠，观察得更多，想得更多，连绝对不常用的“plover”都变得难以忘记，才发现所谓的幸运四叶草，也只不过是“four-leaf clover”（四叶的三叶草）而已。 幸好，镜头下死水微澜，是小野鸭在凫水。 不要等风来，跑起来，它就奔向了你。]]></content>
      <categories>
        <category>随便写写</category>
      </categories>
      <tags>
        <tag>随想</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不问归期来路]]></title>
    <url>%2F2019%2F01%2F01%2F%E4%B8%8D%E9%97%AE%E5%BD%92%E6%9C%9F%E6%9D%A5%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[这条路上的人有很多，在2018这段收费公路上，说真的，还挺挤的（笑）。 我想了好久，这一路我怎么过来的，遇到了哪些人，经历了哪些事。 全部写下来吧。 2017.12.31已经忘了写了什么又删了什么。 2018.01.01 去年的年终总结嗷。 我的2017，疯狂而又迷人。疯狂而安静的高考倒计时，逃晚自习躺操场上看星星，也只有那会儿做得出。“幽暗的萤绿色灯光下，每个人的背影都漾在周边的空气里，或散步，或疾走，或嬉戏，或追闹，放在这片草坪上，零落得像幅静止的画。”这是我的草坪，它留在那儿了。“我有故事，你有酒吗?”“抱歉，我的故事那么无聊，没劲。”高考，以前很看重，可能以后也很看重，至少现在我觉得没那么重要了。它只会决定你的下一步往哪儿走，可是无论你往哪儿走，都会认识一堆槽点满满却又可爱至极的人。俗点，跟史主任说得一样，“只是决定你以后在哪个城市打英雄联盟”，过了那么久，只是英雄联盟变成了吃鸡王者了吧。想得最多的，还怕是那个高考前阵的夜话闲聊和传奇的宜兴爱情故事。六月，考场上潇洒走一回，和想的一样，真的“洒”了一点点，但其实，就像用杯子运水，除非下雨天，否则即使手再稳，也会失去些，蒸发什么的，总是存在的。何况我手也没那么稳。第一首想唱的歌，&lt;成都&gt;，没成想真的来了成都，火锅冒菜串串川菜的天堂，可惜傻鸡没来@驴蛋蛋。一水儿的来四川的兄弟，只剩下一个@连长。诶，啥时候寄点特产来不？@驴蛋蛋想你早日脱单，在线等，挺急的。@许致远 我可能欠自己一份真正的疯狂，至少我现在不后悔。祝你安好，早日脱单。这里得留给帅杨 @骚羊…… 的未成行的和桥烧烤和带劲的重庆小面。@周成瑜 阿华还在田里努力耕作。@徐雨涵 山上新鲜采摘的熊猫。@冯羽韬 骚还是你骚。@朱刚宪 47474747!北边的，南边的，我终将从你们的轨迹中渐渐淡去。我希望那一刻哪怕我糊涂了，我们之间也比陌生人多一层回忆的纸。鸟蒋，蒋汤姆，大炮，懒&lt;菜?傻?-.-&gt;猫，蒋医师，他们都在原地，不会动了，但我会一直带着他们走，直到我走不动了为止。七月上午学车，下午学吉他，最长最浪的暑假没浪起来，单纯充实。吃了贼多各种酒店的谢师宴，感觉神奇，好吧多到不想吃了。@吴好猛哦 八月初疯狂的两人第一次出国自由行，语言不通，眼里全是天书，却那么有趣。因为交通问题去到岚山没坐小火车也没有漂流;在奈良喂鹿，衣服裤子被鹿咬得湿湿的;心斋桥为了买东西，暴走近四万步，穿梭人流，崩溃得不行;又累又饿的朝日生啤+大阪烧，爽;环球影城奇幻的项目和瓢泼的大雨毫不冲突;因为行李受限而穿了n件衣服n条裤子上飞机……遇见了有趣的人有趣的事，还是很好玩呀(｡ì_í｡)田子坊，南京路，科技馆，迪士尼，还记得小时候呆的魔都，没怎么变，迪士尼的人数是真的骚了呀……佛系，佛系。凌晨出发来成都，和爸妈在附近吃了第一顿火锅，那滋味已经忘了，可能比现在的，要美一些。哦对，尼玛全聚德呢？@驴蛋蛋最后又回来了啊:报道，入学，相识，面试，学习……期末。你好，我的2018。 2018.02放假回家三件事 两件事：学Java、TOEFL、宣传部作业（海报和手绘视频~） 视频：https://www.bilibili.com/video/av20413559 2018.03.01做了一个奇怪的梦。 2018.03为了看牙，来来回回上海-成都飞了两三次。 2018.03这学期周三半学期满课来着… 2018.04.15立了一个flag，好的，倒了，今年会加油的哈哈哈哈哈。 有时候直接发公众号了来着。 链接：https://www.jiangluyu.com 2018.05.12复联上映，过了几天去看了，死了很多人。 2018.05.17昨天夜里江安雷暴，窗边的我并没有醒。 2018.05.24这事我要记住的hhh 2018.05.28不知道@连长你记住没有，我帮你回忆回忆hhh 2018.06不管是上课还是考试月今年都有看世界杯嗷。 2018.06.28水漫三八广场 2018.07没想到军训当了标兵。 阿飞走的时候说：“走起，川大的兄弟，未来的精英们，好好学习，相逢就是缘分。” 2018.08.22六级没到600（591），90免修失败 2018.09.14学生会宣讲效果正式破产 2018.10.04第一次参加游戏线下活动 2018.11.25正式加入飞扬（拜师了） 2018.11.30？ 2018.12.09迎新晚会结束了（老父亲般欣慰） 还有很多很多啊，上面的只是空间整理的。 比如换掉了用了一年半一直很喜欢的签名：一棵草，也会为了春天不遗余力。 可能比起上一段路，这一段没有那么冒险刺激，没有那么诗情画意，更多的是躲在幽暗中努力，和朋友们一起患难。这一年睡得不多，无论是从寒假回家开始，还是在学校肝视频，肝项目，肝活动，再加上一些习惯性晚睡，有时候丧，有时候暖。现在想想度过漫漫长夜一定不容易吧，睡觉一定是最好的对策。 生活不易，念且维坚。很感谢你们，这一段路收到了很多惊喜和温暖，还有时不时的交流与吐槽，这一路给了我很重要的力量，黄金日子里，愿友谊常在。路是自己选的，很早的时候就选了，很幸运能够遇到你们，都是可以独舞的灵魂。 今年刷了很多电影，顺便整理了一下，做个参考和留念。【附在后面】 眼看到了2019年了，希望今年拿下期末，拿下TOEFL，KO项目，KO论文，头发变多，继续单身，找到更多的动力，认识更多有趣的灵魂。嗯，剩下的我还没想好。2019应该有2019自己的喜悦与悲伤留给我吧，挺期待的。（flag可别倒啊！） 今年跨年和家乡来的小伙伴们过了，很冷很难忘，真的在成都的街头走一走，还走了一年（笑）。 说来今年成都下雪了，但是江安很小很短，没有积过雪。 窗外无雪，却念雪上人。 附： 弱点 ※※※※※※ 美好的意外 ※ 火锅英雄 ※ 全民情敌 ※※※ 飞行家 ※※※※ 127小时 ※※※ 白日梦想家 ※※※※※※ 真爱至上 ※※※※※※ 彗星来的那一夜 ※※※※ 大空头 ※※※※ 我是谁：没有绝对安全的系统 ※※※ 轻松自由 ※※※※※※ 孤儿怨 / 放牛班的春天 ※※※※※※ 监守自盗 ※※ 返老还童 ※※※※※※ 点球成金 ※※※※※※ 死亡医生 ※※※※ 大而不倒 ※※※※※※ 社交网络 ※※※※※ 成事在人 ※※※※ 无双 ※※※ 传奇的诞生 ※※※※ 你好，之华 ※※※※ 胖子行动队 ※※ 月球 ※※※※ 禁闭岛 ※※※※※※ 私人订制 ※※※ 甲方乙方 ※※※ 让子弹飞 ※※※※※ 一步之遥 ? 邪不压正 ※※※※ 看不见的客人 ※※※※※※ 三块广告牌 ※※※※※※ 玉子爱情故事 ※※※ 达拉斯买家俱乐部 ※※※※※※ 最佳出价 ※※※※ 再次出发 ※※※※※※ 惊天魔盗团2 ※※ 惊天魔盗团 ※※※※ 的士速递 ※※※※ 爱情公寓 ? 超体 ※※※※ 闻香识女人 ※※※※※※ 神奇动物在哪里 ※※※※ 奇异博士 ※※※※ 美丽心灵 ※※※※※※ 心花路放 ※※ 幸福终点站 / 星运里的错 ※※※※※ 头号玩家 ※※※※※※ 闪灵 ※※※※ 泰迪熊2 ※※※ 姚明年 ※※※ 钢琴家 ※※※※※ 火星救援 ※※※※※※ 解救吾先生 ※※※※ 昨日青空 ※※※ 星际穿越 ※※※※※※ 至暗时刻 ※※※※※※]]></content>
      <categories>
        <category>年终总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
</search>
